// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: testCollections.shared.kt
// Package: com.test.collections
import { hashAnything, safeEq } from 'butterfly-web/dist/Kotlin'

//! Declares com.test.collections.CustomEq
export class CustomEq {
    public readonly value: Int;
    public constructor(value: Int) {
        this.value = value;
    }
    public hashCode(): number {
        let hash = 17;
        hash = 31 * hash + hashAnything(this.value);
        return hash;
    }
    public equals(other: any): boolean { return other instanceof CustomEq && safeEq(this.value, other.value) }
    public toString(): string { return `CustomEq(value = ${this.value})` }
    public copy(value: Int = this.value): CustomEq { return new CustomEq(value); }
}

//! Declares com.test.collections.test
export function test(): void {
    const list = listOf<Int>(1, 2, 3);
    
    println(list.get(0));
    
    const pair: Pair<Int, String> = xAnyTo<Int, String>(3, "Three");
    
    println(pair.first);
    println(pair.second);
    
    println(xIterableFilter<Int>(xIterableMap<Int, Int>(list, (it: Int): Int => it.plus(1)), (it: Int): Boolean => safeEq(it.rem(2), 0)));
    println(xListFirstOrNull<Int>(list));
    println(xListSingleOrNull<Int>(list));
    
    xIterableForEach<Int>(xIterableFilterNotNull<Int>(listOf<(Int | null)>(1, 2, null, 4, 8)), (it: Int): Unit => {
            println(it.plus(3));
    });
    
    const mutableList: MutableList<Int> = ArrayList.constructor<Int>();
    
    mutableList.add(1);
    mutableList.add(2);
    mutableList.add(0, 2);
    const x = 0;
    
    const array0 = mutableList;
    const index1 = x.plus(1);
    array0.set(index1, array0.get(x.plus(1), 4).plus(4));
    const array2 = mutableList;
    const index3 = 0;
    array2.set(index3, array2.get(0, 4).plus(4));
    println(mutableList.get(0));
    println(mutableList.size);
    
    const arrayList = ArrayList.constructor<Int>();
    
    arrayList.add(1);
    arrayList.add(2);
    arrayList.add(0, 2);
    const array4 = arrayList;
    const index5 = x.plus(1);
    array4.set(index5, array4.get(x.plus(1), 4).plus(4));
    const array6 = arrayList;
    const index7 = 0;
    array6.set(index7, array6.get(0, 4).plus(4));
    println(arrayList.get(0));
    println(arrayList.size);
    
    println(xIterableJoinToString<String>(listOf<String>("a", "b", "c"), undefined, undefined, undefined, undefined, undefined, undefined));
    println(xIterableJoinToString<String>(listOf<String>("a", "b", "c"), "|", undefined, undefined, undefined, undefined, undefined));
    println(xIterableJoinToString<String>(listOf<String>("a", "b", "c"), "|", undefined, undefined, undefined, undefined, (it: String): CharSequence => it.plus("j")));
    
    const nested = ArrayList.constructor<ArrayList<Int>>();
    
    nested.add(ArrayList.constructor<Int>());
    nested.get(0).add(0);
    
    const seq: Sequence<Int> = sequenceOf<Int>(1, 2, 3);
    
    
    xSequenceForEach<Int>(xSequenceSorted<Int>(xSequenceFilter<Int>(xSequenceMap<Int, Int>(sequenceOf<Int>(1, 2, 3), (it: Int): Int => it.plus(1)), (it: Int): Boolean => safeEq(it.rem(2), 0))), (it: Int): Unit => {
            println(`Got ${it}`);
    });
    
    println(setOf<Int>(1, 2, 3));
    println(setOf<String>("A", "B", "C"));
    println(setOf<Char>('a', 'b', 'c'));
    println(setOf<CustomEq>(new CustomEq(1), new CustomEq(2), new CustomEq(3)));
    
    println(mapOf<Int, Int>(xAnyTo<Int, Int>(1, 2), xAnyTo<Int, Int>(3, 4)));
    println(mapOf<CustomEq, Int>(xAnyTo<CustomEq, Int>(new CustomEq(1), 2), xAnyTo<CustomEq, Int>(new CustomEq(3), 4)));
    
    println(mutableSetOf<Int>(1, 2, 3));
    println(mutableSetOf<String>("A", "B", "C"));
    println(mutableSetOf<Char>('a', 'b', 'c'));
    println(mutableSetOf<CustomEq>(new CustomEq(1), new CustomEq(2), new CustomEq(3)));
    
    println(mutableMapOf<Int, Int>(xAnyTo<Int, Int>(1, 2), xAnyTo<Int, Int>(3, 4)));
    println(mutableMapOf<CustomEq, Int>(xAnyTo<CustomEq, Int>(new CustomEq(1), 2), xAnyTo<CustomEq, Int>(new CustomEq(3), 4)));
    
    println(hashSetOf<Int>(1, 2, 3));
    println(hashSetOf<String>("A", "B", "C"));
    println(hashSetOf<Char>('a', 'b', 'c'));
    println(hashSetOf<CustomEq>(new CustomEq(1), new CustomEq(2), new CustomEq(3)));
    
    println(hashMapOf<Int, Int>(xAnyTo<Int, Int>(1, 2), xAnyTo<Int, Int>(3, 4)));
    println(hashMapOf<CustomEq, Int>(xAnyTo<CustomEq, Int>(new CustomEq(1), 2), xAnyTo<CustomEq, Int>(new CustomEq(3), 4)));
    
    println(HashSet.constructor<Int>());
    println(HashSet.constructor<CustomEq>());
    
    println(HashMap.constructor<Int, String>());
    println(HashMap.constructor<CustomEq, String>());
    
    println(ArrayList.constructor<Int>());
    
    const myMap = HashMap.constructor<Int, Int>();
    
    const array8 = myMap;
    const index9 = 1;
    xMutableMapSet<Int, Int>(index9, 2);
    myMap.put(2, 3);
    myMap.get(0);
    xMutableMapGetOrPut<Int, Int>(myMap, 3, (): Int => 4);
}

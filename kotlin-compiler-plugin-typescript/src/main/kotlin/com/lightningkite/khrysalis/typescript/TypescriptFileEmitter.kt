package com.lightningkite.khrysalis.typescript

import com.lightningkite.khrysalis.analysis.resolvedDeclarationToDescriptor
import com.lightningkite.khrysalis.analysis.resolvedReferenceTarget
import com.lightningkite.khrysalis.generic.FileEmitter
import com.lightningkite.khrysalis.replacements.Import
import com.lightningkite.khrysalis.typescript.replacements.TypescriptImport
import com.lightningkite.khrysalis.util.SmartTabWriter
import com.lightningkite.khrysalis.util.fqNamesToCheck
import com.lightningkite.khrysalis.util.simpleFqName
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.psi.*
import java.io.BufferedWriter

class TypescriptFileEmitter(val translator: TypescriptTranslator, file: KtFile) : FileEmitter(file) {
    val stringBuilder = StringBuilder()
    val out = SmartTabWriter(stringBuilder)
    private val imports = HashMap<String, TypescriptImport>()
    val importedFqs = HashSet<String>()
    val missedImports = HashSet<String>()

    val identifierMap = HashMap<DeclarationDescriptor, String>()
    val importIdentifierMap = HashMap<TypescriptImport, String>()
    val takenIdentifiers = HashSet<String>()
    private fun newName(basedOn: String): String {
        if(takenIdentifiers.add(basedOn)) return basedOn
        var i = 2
        while(true) {
            if(takenIdentifiers.add(basedOn + i.toString())) return basedOn
            i++
        }
    }
    fun getIdentifier(descriptor: DeclarationDescriptor): String? {
        return identifierMap.getOrPut(descriptor) {
            when(descriptor) {
                is KtNamedFunction -> descriptor.nameAsName?.asString()?.let(::newName) ?: return null
                is KtClassLikeDeclaration -> descriptor.nameAsName?.asString()?.let(::newName) ?: return null
                is KtProperty -> descriptor.nameAsName?.asString()?.let(::newName) ?: return null
                else -> return null
            }
        }
    }
    init {
        // Identifier analysis
        // Local top-level names get top priority
        file.declarations.forEach { it.resolvedDeclarationToDescriptor?.let { getIdentifier(it) } }
    }

    companion object {
        val overwriteWarning = "// Generated by Khrysalis TypeScript converter - this file will be overwritten."
    }

    fun write(writer: BufferedWriter, file: KtFile) {
        render(writer)
        writer.flush()
    }

    //Map of FQ name to import info
    fun addImport(path: String, identifier: String, asName: String? = null) {
        val fqName = "$path->$identifier"
        if (imports.containsKey(fqName)) return
        imports[fqName] = TypescriptImport(path, identifier, newName(asName ?: identifier))
    }

    private fun addImportFromFq(fqName: String, name: String): Boolean {
        val newImport = translator.declarations.importLine(
            from = file,
            fqName = fqName,
            name = name
        )
        if(newImport != null) {
            addImport(newImport)
            return true
        }
        return false
    }

    fun addImport(decl: DeclarationDescriptor, overrideName: String? = null) {
        val useDecl = when (decl) {
            is ConstructorDescriptor -> decl.containingDeclaration
            is ClassDescriptor -> if(decl.isCompanionObject) decl.containingDeclaration else decl
            else -> decl
        }
        val name = overrideName ?: useDecl.name.asString().safeJsIdentifier()
        val n = "${useDecl.simpleFqName} TS $name"
        if (importedFqs.contains(n))
            return
        importedFqs.add(n)
        useDecl.fqNamesToCheck.firstOrNull {
            addImportFromFq(it, name)
        } ?: missedImports.add(n)
    }

    override fun addImport(import: Import) {
        if(import is TypescriptImport) {
            addImport(
                path = import.path,
                identifier = import.identifier,
                asName = import.asName
            )
        } else throw IllegalArgumentException("TypescriptImport expected, got $import")
    }

    override fun renderImports(to: Appendable) {
        val relPath = file.virtualFilePath.removePrefix(translator.commonPath)
        renderImports(translator.projectName, relPath, imports.values, to)
    }

    override fun sub(): FileEmitter = TypescriptFileEmitter(translator, file)

    fun addImports(parts: Iterable<TypescriptImport>) {
        for (p in parts) addImport(p)
    }
}
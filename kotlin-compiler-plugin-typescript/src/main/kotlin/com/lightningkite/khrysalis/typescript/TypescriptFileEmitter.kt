package com.lightningkite.khrysalis.typescript

import com.lightningkite.khrysalis.typescript.replacements.TemplatePart
import com.lightningkite.khrysalis.util.SmartTabWriter
import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.load.java.descriptors.JavaPropertyDescriptor
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameOrNull
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
import org.jetbrains.kotlin.resolve.descriptorUtil.getImportableDescriptor
import org.jetbrains.kotlin.synthetic.SyntheticJavaPropertyDescriptor
import java.io.BufferedWriter
import java.io.File

class TypescriptFileEmitter(val translator: TypescriptTranslator, val file: KtFile) : Appendable {
    val stringBuilder = StringBuilder()
    val out = SmartTabWriter(stringBuilder)
    private val imports = HashMap<String, ImportInfo>()
    val importedFqs = HashSet<String>()
    var fileEndingActions = ArrayList<() -> Unit>()

    companion object {
        val overwriteWarning = "// Generated by Khrysalis TypeScript converter - this file will be overwritten."
    }

    fun write(writer: BufferedWriter, file: KtFile) {
        writer.appendln(overwriteWarning)
        writer.appendln("// File: ${file.virtualFilePath.removePrefix(translator.commonPath)}")
        writer.appendln("// Package: ${file.packageFqName.asString()}")
        importedFqs.forEach {
            writer.appendln("// FQImport: $it")
        }
        imports.values.groupBy { it.path }.forEach { (path, parts) ->
            val usePath = translator.projectName?.let { p ->
                val prefix = "$p/dist/"
                if (path.startsWith(prefix, true))
                    path.drop(prefix.length)
                else
                    path
            } ?: path
            if (parts.size == 1 && parts.first().identifier == TemplatePart.Import.WHOLE) {
                writer.append("import ")
                writer.append(parts.first().identifier)
                writer.append(" from '")
                writer.append(usePath)
                writer.appendln("'")
            } else {
                writer.append("import { ")
                writer.append(parts.sortedBy { it.asName ?: it.identifier }.joinToString(", ") {
                    it.asName?.let { name ->
                        it.identifier + " as " + name
                    } ?: it.identifier
                })
                writer.append(" } from '")
                writer.append(usePath)
                writer.appendln("'")
            }
        }
        writer.appendln()

        out.flush()
        writer.appendln(stringBuilder)

        while (fileEndingActions.isNotEmpty()) {
            stringBuilder.clear()
            stringBuilder.appendln()
            val copy = fileEndingActions
            fileEndingActions = ArrayList()
            copy.forEach { it() }
            out.flush()
            writer.appendln(stringBuilder)
        }
    }

    private data class ImportInfo(
        val path: String,
        val identifier: String,
        val asName: String? = null
    )

    //Map of FQ name to import info
    fun addImport(path: String, identifier: String, asName: String? = null) {
        val fqName = "$path->$identifier"
        if (imports.containsKey(fqName)) return
        imports[fqName] = ImportInfo(path, identifier, asName)
    }

    private fun addImportFromFq(fqName: String, name: String) {
        translator.kotlinFqNameToRelativeFile[fqName]?.let { relFile ->
            val asPath = File(file.virtualFilePath.removePrefix(translator.commonPath).removeSuffix(".kt").plus(".ts"))
            if (asPath == relFile) {
                importedFqs.add("$fqName SKIPPED due to same file")
            } else {
                addImport(TemplatePart.Import("./" + (asPath.parentFile?.let { p -> relFile.relativeTo(p).path }
                    ?: relFile.path).removeSuffix(".ts"), name))
            }
        } ?: translator.kotlinFqNameToFile[fqName]?.let {
            addImport(TemplatePart.Import(it.path.removeSuffix(".ts"), name))
        }
    }

    fun addImport(decl: DeclarationDescriptor, overrideName: String? = null) {
        val useDecl = when (decl) {
            is ConstructorDescriptor -> decl.containingDeclaration
            else -> decl
        }
        val name = overrideName ?: useDecl.name.asString()
        val fq = when (decl) {
            is SyntheticJavaPropertyDescriptor -> {
                val result = decl.getMethod.containingDeclaration.fqNameSafe.asString() + "." + decl.fqNameSafe.asString()
                translator.collector?.report(
                    CompilerMessageSeverity.INFO,
                    "${decl.fqNameSafe.asString()} is a SyntheticJavaPropertyDescriptor, returning $result"
                )
                result
            }
            else -> useDecl.fqNameSafe.asString()
        }
        val n = "$fq TS $name"
        if (importedFqs.contains(n))
            return
        importedFqs.add(n)
        addImportFromFq(fq, name)
    }

    fun addImport(part: TemplatePart.Import) {
        addImport(
            path = part.path,
            identifier = part.identifier,
            asName = part.asName
        )
    }

    fun addImports(parts: Iterable<TemplatePart.Import>) {
        for (p in parts) addImport(p)
    }

    override fun append(p0: CharSequence): Appendable {
        out.append(p0)
        return this
    }

    override fun append(p0: CharSequence, p1: Int, p2: Int): Appendable {
        out.append(p0, p1, p2)
        return this
    }

    override fun append(p0: Char): Appendable {
        out.append(p0)
        return this
    }
}
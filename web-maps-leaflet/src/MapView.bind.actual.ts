// Generated by Khrysalis TypeScript converter
// File: MapView.bind.actual.kt
// Package: com.lightningkite.khrysalis.maps
import {MutableObservableProperty} from 'khrysalis/dist/observables/MutableObservableProperty.shared'
import {GeoCoordinate} from 'khrysalis/dist/location/GeoCoordinate.shared'
import {ObservableProperty} from 'khrysalis/dist/observables/ObservableProperty.shared'
import {LeafletMouseEvent, map as makeMap, Map, marker as makeMarker, Marker} from 'leaflet'
import {
    xViewRemovedGet,
    xDisposableUntil
} from "khrysalis/dist/rx/DisposeCondition.actual";
import {xObservablePropertySubscribeBy} from "khrysalis/dist/observables/ObservableProperty.ext.shared";
import {customViewInvalidate} from "khrysalis/dist/views/CustomView.actual";

const mapSymbol = Symbol("mapSymbol");
declare global {
    interface HTMLDivElement {
        [mapSymbol]: Map;
    }
}

let configureMap: (m: Map, style: string | null) => void = () => {
};

/**
 * Set up a map source.
 * MapBox example:
 * (map, styleString) => {
 *     tileLayer(
 *         `https://api.tiles.mapbox.com/v4/mapbox.streets/{z}/{x}/{y}.png?access_token=${accessToken}`,
 *         {
 *             attribution: `Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>`,
 *             maxZoom: 18
 *         }
 *     ).addTo(map);
 * }
 */
export function setMapConfiguration(source: (m: Map, style: string | null) => void) {
    configureMap = source;
}

//! Declares com.google.android.gms.maps.MapView.getMapAsync
export function getMapAsync(this_: HTMLDivElement, action: (a: Map) => void) {
    const m = this_[mapSymbol];
    if (m) {
        action(m);
    }
}

//! Declares com.lightningkite.khrysalis.maps.bind>com.google.android.gms.maps.MapView
export function xMapViewBind(this_: HTMLDivElement, dependency: Window, style: string | null): void {
    const map = makeMap(this_);
    map.setView([0,0], 1)
    configureMap(map, style);
    this_[mapSymbol] = map;

    const obs = new ResizeObserver(function callback(){
        console.log("Invalidating size...")
        map.invalidateSize()
        if(!document.contains(this_)) {
            obs.disconnect();
        }
    });
    obs.observe(this_);
}

//! Declares com.lightningkite.khrysalis.maps.bindView>com.google.android.gms.maps.MapView
export function xMapViewBindView(this_: HTMLDivElement, dependency: Window, position: ObservableProperty<(GeoCoordinate | null)>, zoomLevel: number = 15, animate: boolean = true, style: string | null = null): void {
    xMapViewBind(this_, dependency, style);
    const map = this_[mapSymbol];
    let first = true;
    let marker: Marker | null = null;
    xDisposableUntil(xObservablePropertySubscribeBy(position, undefined, undefined, (g: GeoCoordinate | null)=>{
        if(g){
            const p: [number, number] = [g.latitude, g.longitude];
            map.setView(p, zoomLevel, { animate: animate && !first });
            first = false;
            if(!marker){
                marker = makeMarker(p);
                map.addLayer(marker);
            } else {
                marker.setLatLng(p);
            }
        } else {
            if(marker) {
                map.removeLayer(marker);
                marker = null;
            }
        }
    }), xViewRemovedGet(this_));
}


//! Declares com.lightningkite.khrysalis.maps.bindSelect>com.google.android.gms.maps.MapView
export function xMapViewBindSelect(this_: HTMLDivElement, dependency: Window, position: MutableObservableProperty<(GeoCoordinate | null)>, zoomLevel: number = 15, animate: boolean = true, style: string | null = null): void {
    xMapViewBind(this_, dependency, style);
    const map = this_[mapSymbol];
    let first = true;
    let marker: Marker | null = null;
    xDisposableUntil(xObservablePropertySubscribeBy(position, undefined, undefined, (g: GeoCoordinate | null)=>{
        const currentPos = marker?.getLatLng();
        if(currentPos?.lng == g?.longitude && currentPos?.lng == g?.latitude) return
        if(g){
            const p: [number, number] = [g.latitude, g.longitude];
            map.setView(p, zoomLevel, { animate: animate && !first });
            first = false;
            if(!marker){
                marker = makeMarker(p, { draggable: true });
                marker.on("drag", (e)=>{
                    if(marker){
                        const raw = marker.getLatLng()
                        position.value = new GeoCoordinate(raw.lat, raw.lng);
                    }
                })
                map.addLayer(marker);
            } else {
                marker.setLatLng(p);
            }
        } else {
            if(marker) {
                map.removeLayer(marker);
                marker = null;
            }
        }
    }), xViewRemovedGet(this_));
    map.on('click', (e: LeafletMouseEvent)=>{
        if(!marker){
            position.value = new GeoCoordinate(e.latlng.lat, e.latlng.lng);
        }
    })
}


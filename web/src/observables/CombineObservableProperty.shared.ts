// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: observables/CombineObservableProperty.shared.kt
// Package: com.lightningkite.khrysalis.observables
import { map as rxMap, skip as rxSkip } from 'rxjs/operators'
import { ObservableProperty } from './ObservableProperty.shared'
import { Observable, combineLatest as rxCombineLatest, concat as rxConcat, of as rxOf } from 'rxjs'

//! Declares com.lightningkite.khrysalis.observables.CombineObservableProperty
export class CombineObservableProperty<T, A, B> extends ObservableProperty<T> {
    public readonly observableA: ObservableProperty<A>;
    public readonly observableB: ObservableProperty<B>;
    public readonly combiner:  ((a: A, b: B) => T);
    public constructor(observableA: ObservableProperty<A>, observableB: ObservableProperty<B>, combiner:  ((a: A, b: B) => T)) {
        super();
        this.observableA = observableA;
        this.observableB = observableB;
        this.combiner = combiner;
    }
    
    //! Declares com.lightningkite.khrysalis.observables.CombineObservableProperty.value
    public get value(): T { return this.combiner(this.observableA.value, this.observableB.value); }
    
    //! Declares com.lightningkite.khrysalis.observables.CombineObservableProperty.onChange
    public get onChange(): Observable<T> {
        const combinerCopy = this.combiner;
        
        return rxCombineLatest([rxConcat(rxOf(this.observableA.value), this.observableA.onChange), rxConcat(rxOf(this.observableB.value), this.observableB.onChange)]).pipe(rxMap(x => ( (a: A, b: B): T => combinerCopy(a, b))(x[0], x[1]))).pipe(rxSkip(0));
    }
    
}

//! Declares com.lightningkite.khrysalis.observables.combine>com.lightningkite.khrysalis.observables.ObservableProperty<kotlin.Any>
export function xObservablePropertyCombine<T, B, C>(this_: ObservableProperty<T>, other: ObservableProperty<B>, combiner:  ((a: T, b: B) => C)): ObservableProperty<C> {
    return new CombineObservableProperty<C, T, B>(this_, other, combiner);
}


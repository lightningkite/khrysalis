// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: observables/ObservableStack.shared.kt
// Package: com.lightningkite.khrysalis.observables
import { ObservableProperty } from './ObservableProperty.shared'
import { NumberRange, checkIsInterface } from '../Kotlin'
import { HasBackAction } from '../views/HasBackAction.shared'
import { Subject } from 'rxjs'

//! Declares com.lightningkite.khrysalis.observables.ObservableStack
export class ObservableStack<T extends object> extends ObservableProperty<Array<T>> {
    public constructor() {
        super();
        this.onChange = new Subject();
        this.stack = ([] as Array<T>);
    }
    
    
    
    
    public readonly onChange: Subject<Array<T>>;
    
    //! Declares com.lightningkite.khrysalis.observables.ObservableStack.value
    public get value(): Array<T> {
        return this.stack;
    }
    
    
    public readonly stack: Array<T>;
    
    
    public push(t: T): void {
        this.stack.push(t);
        this.onChange.next(this.stack);
    }
    
    public swap(t: T): void {
        this.stack.splice((this.stack.length - 1), 1)[0];
        this.stack.push(t);
        this.onChange.next(this.stack);
    }
    
    public pop(): boolean {
        if (this.stack.length <= 1) {
            return false;
        }
        this.stack.splice((this.stack.length - 1), 1)[0];
        this.onChange.next(this.stack);
        return true;
    }
    
    public dismiss(): boolean {
        if (this.stack.length === 0) {
            return false;
        }
        this.stack.splice((this.stack.length - 1), 1)[0];
        this.onChange.next(this.stack);
        return true;
    }
    
    public backPressPop(): boolean {
        const last = ((): (T | null) => {
                const temp99 = this.stack;
                return (temp99[temp99.length - 1] ?? null)
        })();
        
        if (checkIsInterface<HasBackAction>(last, "ComLightningkiteKhrysalisViewsHasBackAction") && (last as HasBackAction).onBackPressed()) { return true }
        return this.pop();
    }
    
    public backPressDismiss(): boolean {
        const last = ((): (T | null) => {
                const temp100 = this.stack;
                return (temp100[temp100.length - 1] ?? null)
        })();
        
        if (checkIsInterface<HasBackAction>(last, "ComLightningkiteKhrysalisViewsHasBackAction") && (last as HasBackAction).onBackPressed()) { return true }
        return this.dismiss();
    }
    
    public popTo(t: T): void {
        let found = false;
        
        for (const i of new NumberRange(0, (this.stack.length - 1))) {
            if (found) {
                this.stack.splice((this.stack.length - 1), 1)[0];
            } else { if (this.stack[i] === t) {
                    found = true;
            } }
        }
        this.onChange.next(this.stack);
    }
    
    public popToPredicate(predicate: ((a: T) => boolean)): void {
        let found = false;
        
        for (const i of new NumberRange(0, (this.stack.length - 1))) {
            if (found) {
                this.stack.splice((this.stack.length - 1), 1)[0];
            } else { if (predicate(this.stack[i])) {
                    found = true;
            } }
        }
        this.onChange.next(this.stack);
    }
    
    public root(): void {
        this.popTo(this.stack[0]);
    }
    
    public reset(t: T): void {
        this.stack.length = 0;
        this.stack.push(t);
        this.onChange.next(this.stack);
    }
}
export namespace ObservableStack {
    //! Declares com.lightningkite.khrysalis.observables.ObservableStack.Companion
    export class Companion {
        private constructor() {
        }
        public static INSTANCE = new Companion();
        
        public withFirst<T extends object>(value: T): ObservableStack<T> {
            const result = new ObservableStack<T>();
            
            result.reset(value);
            return result;
        }
    }
}


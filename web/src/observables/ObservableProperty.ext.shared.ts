// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: observables/ObservableProperty.ext.shared.kt
// Package: com.lightningkite.khrysalis.observables
import { Observable, Observer, SubscriptionLike, concat as rxConcat } from 'rxjs'
import { ObservableProperty } from './ObservableProperty.shared'
import { xObservablePropertyMap } from './TransformedObservableProperty.shared'
import { EqualOverrideSet } from '../KotlinCollections'
import { printStackTrace } from '../kotlin/Language'
import { map as rxMap } from 'rxjs/operators'
import { MutableObservableProperty } from './MutableObservableProperty.shared'
import { xObservablePropertyWithWrite } from './WriteAddedObservableProperty.shared'

//! Declares com.lightningkite.khrysalis.observables.observable>com.lightningkite.khrysalis.observables.ObservableProperty<kotlin.Any>
export function xObservablePropertyObservableGet<T>(this_: ObservableProperty<T>): Observable<T> { return rxConcat(new Observable((it: Observer<T>): void => {
                it.next(this_.value); it.complete();
}), this_.onChange); }

//! Declares com.lightningkite.khrysalis.observables.observableNN>com.lightningkite.khrysalis.observables.ObservableProperty<kotlin.Any>
export function xObservablePropertyObservableNNGet<T>(this_: ObservableProperty<T>): Observable<T> { return rxConcat(new Observable((it: Observer<T>): void => {
                it.next(this_.value); it.complete();
}), this_.onChange).pipe(rxMap((it: T): T => it)); }

//! Declares com.lightningkite.khrysalis.observables.onChangeNN>com.lightningkite.khrysalis.observables.ObservableProperty<kotlin.Any>
export function xObservablePropertyOnChangeNNGet<T>(this_: ObservableProperty<T>): Observable<T> { return this_.onChange.pipe(rxMap((it: T): T => it)); }


//! Declares com.lightningkite.khrysalis.observables.subscribeBy>com.lightningkite.khrysalis.observables.ObservableProperty<kotlin.Any>
export function xObservablePropertySubscribeBy<T>(this_: ObservableProperty<T>, onError:  ((a: any) => void) = (it: any): void => {
        printStackTrace(it);
}, onComplete:  (() => void) = (): void => {}, onNext:  ((a: T) => void) = (it: T): void => {}): SubscriptionLike { 
    return xObservablePropertyObservableGet(this_).subscribe((boxed: T): void => {
            onNext(boxed);
    }, onError, onComplete); 
}

//! Declares com.lightningkite.khrysalis.observables.includes
export function includes<E>(collection: MutableObservableProperty<Set<E>>, element: E): MutableObservableProperty<boolean> {
    return xObservablePropertyWithWrite<boolean>(xObservablePropertyMap<Set<E>, boolean>(collection, (it: Set<E>): boolean => it.has(element)), (it: boolean): void => {
            if (it) {
                collection.value = new EqualOverrideSet([...collection.value, element]);
            } else {
                collection.value = new EqualOverrideSet([...collection.value].filter(x => x !== element));
            }
    });
}

//! Declares com.lightningkite.khrysalis.observables.whileActive>com.lightningkite.khrysalis.observables.ObservableProperty<kotlin.Boolean>
export function xObservablePropertyWhileActive(this_: ObservableProperty<boolean>, action:  (() => SubscriptionLike)): SubscriptionLike {
    let current: (SubscriptionLike | null) = null;
    
    return xObservablePropertySubscribeBy<boolean>(this_, undefined, undefined, (it: boolean): void => {
            if (it) {
                if (current === null) {
                    current = action();
                }
            } else {
                const temp76 = current;
                if(temp76 !== null) { 
                    temp76.unsubscribe()
                };
                current = null;
            }
    });
}

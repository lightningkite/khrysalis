// Generated by Khrysalis TypeScript converter
// File: net/HttpClient.actual.kt
// Package: com.lightningkite.khrysalis.net
import {from, Observable, SchedulerLike, Subject, using} from 'rxjs'
import {ConnectedWebSocket} from "./ConnectedWebSocket.actual";
import {HttpBody} from "./HttpBody.actual";
import {Exception} from "../kotlin/Language";
import {map, timeout} from "rxjs/operators";
import {HttpCacheMode, HttpOptions, HttpPhase, HttpProgress} from "./HttpModels.shared";
import {ObservableProperty} from "../observables/ObservableProperty.shared";
import {ioReactivexObservableAsObservableProperty} from "../observables/EventToObservableProperty.shared";

//! Declares com.lightningkite.khrysalis.net.HttpClient
export class HttpClient {
    public static INSTANCE = new HttpClient();

    public readonly GET = "GET";
    public readonly POST = "POST";
    public readonly PUT = "PUT";
    public readonly PATCH = "PATCH";
    public readonly DELETE = "DELETE";

    //--- HttpClient.ioScheduler
    public ioScheduler: SchedulerLike | null = null

    //--- HttpClient.responseScheduler
    public responseScheduler: SchedulerLike | null = null

    public defaultOptions: HttpOptions = new HttpOptions();

    call(
        url: string,
        method: string = HttpClient.INSTANCE.GET,
        headers: Map<string, string> = new Map([]),
        body: (HttpBody | null) = null,
        options: HttpOptions = this.defaultOptions
    ): Observable<Response> {
        let h = new Array(...headers.entries());
        if(body !== null){
            h.push(["Content-Type", body.type]);
        }
        let cacheString: RequestCache = "default"
        switch(options.cacheMode) {
            case HttpCacheMode.Default:
                cacheString = "default"
                break
            case HttpCacheMode.NoStore:
                cacheString = "no-store"
                break
            case HttpCacheMode.Reload:
                cacheString = "reload"
                break
            case HttpCacheMode.NoCache:
                cacheString = "no-cache"
                break
            case HttpCacheMode.ForceCache:
                cacheString = "force-cache"
                break
            case HttpCacheMode.OnlyIfCached:
                cacheString = "only-if-cached"
                break
        }
        return from(fetch(url, {
            body: body?.data,
            cache: cacheString,
            credentials: "omit",
            headers: h,
            method: method
        })).pipe(timeout(options.callTimeout ?? (
            (options.connectTimeout ?? 5_000) + (options.readTimeout ?? 5_000) + (options.writeTimeout ?? 5_000)
        )))
    }

    callWithProgress(
        url: string,
        method: string = HttpClient.INSTANCE.GET,
        headers: Map<string, string> = new Map([]),
        body: (HttpBody | null) = null,
        options: HttpOptions = this.defaultOptions
    ): [ObservableProperty<HttpProgress>, Observable<Response>] {
        let h = new Array(...headers.entries());
        if(body !== null){
            h.push(["Content-Type", body.type]);
        }
        let cacheString: RequestCache = "default";
        switch(options.cacheMode) {
            case HttpCacheMode.Default:
                cacheString = "default";
                break
            case HttpCacheMode.NoStore:
                cacheString = "no-store";
                break
            case HttpCacheMode.Reload:
                cacheString = "reload";
                break
            case HttpCacheMode.NoCache:
                cacheString = "no-cache";
                break
            case HttpCacheMode.ForceCache:
                cacheString = "force-cache";
                break
            case HttpCacheMode.OnlyIfCached:
                cacheString = "only-if-cached";
                break
        }
        let progSubj = new Subject<HttpProgress>();
        let obsResp = from(fetch(url, {
            body: body?.data,
            cache: cacheString,
            credentials: "omit",
            headers: h,
            method: method
        })).pipe(timeout(options.callTimeout ?? (
            (options.connectTimeout ?? 5_000) + (options.readTimeout ?? 5_000) + (options.writeTimeout ?? 5_000)
        ))).pipe(map((response)=>{
            const contentEncoding = response.headers.get('content-encoding');
            const contentLengthStr = response.headers.get(contentEncoding ? 'x-file-size' : 'content-length');
            const contentLength = contentLengthStr ? parseInt(contentLengthStr) : null;
            const existingBody = response.body;
            if(existingBody){
                const newReader = existingBody.getReader();
                let loadedBytes = 0;
                return new Response(
                    new ReadableStream({
                        start(controller) {
                            read();
                            function read() {
                                newReader.read().then(({done, value}) => {
                                    if (done) {
                                        //on progress complete
                                        progSubj.next(new HttpProgress(HttpPhase.Read, 1))
                                        controller.close();
                                        return;
                                    }
                                    if(value){
                                        loadedBytes += value.byteLength;
                                        //on progress
                                        if(contentLength) {
                                            progSubj.next(new HttpProgress(HttpPhase.Read, loadedBytes / contentLength))
                                        } else {
                                            progSubj.next(new HttpProgress(HttpPhase.Read, approximateCompletion(loadedBytes)))
                                        }
                                        controller.enqueue(value);
                                    }
                                    read();
                                }).catch(error => {
                                    console.error(error);
                                    controller.error(error)
                                });
                            }
                        }
                    }),
                    response
                );
            } else {
                return new Response(
                    null,
                    response
                );
            }
        }))
        let progObs = ioReactivexObservableAsObservableProperty(progSubj, HttpProgress.Companion.INSTANCE.connecting);
        return [progObs, obsResp];
    }
    
    webSocket(url: string): Observable<ConnectedWebSocket>{
        return using<ConnectedWebSocket>(
            ()=> {
                const out = new ConnectedWebSocket(url)
                // out.underlyingSocket =
                return out
            },
            (r) => (r as ConnectedWebSocket).ownConnection
        )
    }
}

function approximateCompletion(x: number): number {
    return 1 - 1 / (x * 10_000 + 1)
}
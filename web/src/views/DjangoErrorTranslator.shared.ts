// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: views/DjangoErrorTranslator.shared.kt
// Package: com.lightningkite.khrysalis.views
import { ViewString, ViewStringRaw, ViewStringResource } from './Strings.shared'
import { StringBuilder } from '../kotlin/kotlin.text'
import { checkIsInterface } from '../Kotlin'
import { xStringFromJsonStringUntyped } from '../Codable.actual'
import { xCharIsUpperCase } from '../kotlin/kotlin.text'

//! Declares com.lightningkite.khrysalis.views.DjangoErrorTranslator
export class DjangoErrorTranslator {
    public readonly connectivityErrorResource: string;
    public readonly serverErrorResource: string;
    public readonly otherErrorResource: string;
    public constructor(connectivityErrorResource: string, serverErrorResource: string, otherErrorResource: string) {
        this.connectivityErrorResource = connectivityErrorResource;
        this.serverErrorResource = serverErrorResource;
        this.otherErrorResource = otherErrorResource;
    }
    
    
    public handleNode(builder: StringBuilder, node: (any | null)): void {
        if (node === null) { return }
        if (checkIsInterface<Map<(any | null), (any | null)>>(node!, "KotlinCollectionsMap")){
            for (const toDestructure of (node as Map<(any | null), (any | null)>)) {
                const key = toDestructure[0]
                const value = toDestructure[1]
                
                this.handleNode(builder, value)
                
            }
        } else if (checkIsInterface<Array<(any | null)>>(node!, "KotlinCollectionsList")){
            for (const value of (node as Array<(any | null)>)) {
                this.handleNode(builder, value);
            }
        } else if (typeof (node!) == "string"){
            //Rough check for human-readability - sentences start with uppercase and will have spaces
            if ((node as string) !== "" && xCharIsUpperCase((node as string)[0]) && ((node as string).indexOf(" ") != -1)) {
                builder.value += (node as string) + '\n';
            }
        }
    }
    public parseError(code: number, error: (string | null)): (ViewString | null) {
        let resultError: (ViewString | null) = null;
        
        switch(code / 100) {
            case 0:
            resultError = new ViewStringResource(this.connectivityErrorResource)
            break;
            case 1:
            case 2:
            case 3:
            
            break;
            case 4:
            const errorJson = ((): (any | null) => {
                    if(error !== null) {
                        return xStringFromJsonStringUntyped(error)
                    } else { return null }
            })();
            
            if (errorJson !== null) {
                const builder = new StringBuilder();
                
                this.handleNode(builder, errorJson);
                resultError = new ViewStringRaw(builder.toString());
            } else {
                resultError = new ViewStringRaw(error ?? "");
            }
            break;
            case 5:
            resultError = new ViewStringResource(this.serverErrorResource)
            break;
            default:
            resultError = new ViewStringResource(this.otherErrorResource)
            break;
        }
        
        return resultError;
    }
    
    public wrap<T>(callback:  ((result: (T | null), error: (ViewString | null)) => void)): ((code: number, result: (T | null), error: (string | null)) => void) {
        return (code: number, result: (T | null), error: (string | null)): void => {
            callback(result, this.parseError(code, error));
        };
    }
    
    public wrapNoResponse(callback:  ((error: (ViewString | null)) => void)): ((code: number, error: (string | null)) => void) {
        return (code: number, error: (string | null)): void => {
            callback(this.parseError(code, error));
        };
    }
    
}


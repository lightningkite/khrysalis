// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: rx/RxActual.actual.kt
// Package: com.lightningkite.khrysalis.rx
// FQImport: com.lightningkite.khrysalis.observables.asObservableProperty TS ioReactivexObservableAsObservableProperty
// FQImport: com.lightningkite.khrysalis.rx.test.<anonymous>.it TS it
// FQImport: io.reactivex.Observable.observeOn TS observeOn
// FQImport: io.reactivex.android.schedulers.AndroidSchedulers TS AndroidSchedulers
// FQImport: io.reactivex.android.schedulers.AndroidSchedulers.mainThread TS mainThread
import { flatMap as rxFlatMap, map as rxMap } from 'rxjs/operators'
import { Observable, of as rxOf } from 'rxjs'
import { ioReactivexObservableAsObservableProperty } from './../observables/EventToObservableProperty.shared'

function test(){
    rxFlatMap((it) => rxOf(it, it + 1))(rxMap((it) => it + 1)(rxOf(1, 2, 3))).observeOn(AndroidSchedulers.mainThread()).subscribe(undefined, (it) => console.log(it), undefined).unsubscribe();
    new Observable<number>((it: Observer<number>) => {
            it.next(3);; it.complete();
    }).subscribe(undefined, (it) => console.log(it), undefined).unsubscribe();
    return ioReactivexObservableAsObservableProperty(new Observable<number>((it: Observer<number>) => {
                it.next(3);; it.complete();
    }), 1);
    
}


/* SHARED DECLARATIONS
class Observable<Element> {
    fun <Destination> map(conversion: (Element)->Destination): Observable<Destination>
    fun filter(predicate: (Element)->Boolean): Observable<Element>
    fun <Destination> flatMap(conversion: (Element)->Observable<Destination>): Observable<Destination>
    fun <Destination> switchMap(conversion: (Element)->Observable<Destination>): Observable<Destination>
    fun subscribeOn(scheduler: Scheduler): Observable<Element>
    fun observeOn(scheduler: Scheduler): Observable<Element>
    
    fun subscribeBy(
        onError: (Throwable) -> Unit,
        onComplete: () -> Unit,
        onNext: (Element) -> Unit
    ): Disposable
    
    companion object {
        fun create(action: (ObservableEmitter<Element>)->Unit): Observable<Element>
        fun just(vararg args: Element): Observable<Element>
        fun empty(): Observable<Element>
    }
}
class Subject<Element> {
    fun onNext(value: Element)
    fun onError(error: Exception)
    fun onComplete()
}

class Single<Element> {
    fun <Destination> map(conversion: (Element)->Destination): Single<Destination>
    fun <Destination> flatMap(conversion: (Element)->Observable<Destination>): Single<Destination>
    fun subscribeOn(scheduler: Scheduler): Single<Element>
    fun observeOn(scheduler: Scheduler): Single<Element>
    
    fun toObservable(): Observable<Element>
    
    fun subscribeBy(
        onError: (Throwable) -> Unit,
        onSuccess: (Element) -> Unit
    ): Disposable
    
    fun cache(): Single<Element>
    fun doOnSubscribe(action: ()->Unit): Single<Element>
    fun doFinally(action: ()->Unit): Single<Element>
    fun doOnSuccess(action: (Element)->Unit): Single<Element>
    fun doOnError(action: (Exception)->Unit): Single<Element>
    
    companion object {
        fun create(action: (SingleEmitter<Element>)->Unit): Single<Element>
        fun just(arg: Element): Single<Element>
    }
}

typealias Scheduler = ImmediateModeScheduler
object Schedulers {
    fun newThread(): Scheduler
    fun io(): Scheduler
}
object AndroidSchedulers {
    fun mainThread(): Scheduler
}

fun <Element> BehaviorSubject.Companion.create(value: Element): BehaviorSubject<Element>
fun <Element> PublishSubject.Companion.create(): PublishSubject<Element>

*/


// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: net/HttpResponse.actual.kt
// Package: com.lightningkite.khrysalis.net
// FQImport: okhttp3.ResponseBody.string TS string
// FQImport: okhttp3.Headers.toMultimap TS toMultimap
// FQImport: com.lightningkite.khrysalis.net.readJson.T TS T
// FQImport: kotlin.collections.Map TS Map
// FQImport: okhttp3.Response TS Response
// FQImport: com.lightningkite.khrysalis.net.HttpClient.mapper TS mapper
// FQImport: com.fasterxml.jackson.core.type.TypeReference TS TypeReference
// FQImport: com.lightningkite.khrysalis.net.<get-headers>.<anonymous>.it TS it
// FQImport: com.lightningkite.khrysalis.net.readText SKIPPED due to same file
// FQImport: okhttp3.Response.code TS code
// FQImport: kotlin.collections.mapValues TS kotlinCollectionsMapMapValues
// FQImport: okhttp3.Response.headers TS headers
// FQImport: com.fasterxml.jackson.module.kotlin.readValue TS comFasterxmlJacksonDatabindObjectMapperReadValue
// FQImport: kotlin.Exception TS Exception
// FQImport: com.lightningkite.khrysalis.net.readJson.e TS e
// FQImport: com.fasterxml.jackson.databind.ObjectMapper.readValue TS readValue
// FQImport: java.lang.IllegalStateException TS IllegalStateException
// FQImport: kotlin.collections.joinToString TS kotlinCollectionsIterableJoinToString
// FQImport: com.lightningkite.khrysalis.net.HttpResponse SKIPPED due to same file
// FQImport: okhttp3.Response.body TS body
// FQImport: com.lightningkite.khrysalis.net.readJson.raw TS raw
// FQImport: com.lightningkite.khrysalis.net.readText TS okhttp3ResponseReadText
// FQImport: com.lightningkite.khrysalis.net.HttpResponse TS HttpResponse
// FQImport: com.lightningkite.khrysalis.net.readJson.typeToken TS typeToken
// FQImport: kotlin.collections.Map.Entry.value TS value

//! Declares com.lightningkite.khrysalis.net.HttpResponse
export type HttpResponse = Response;
//! Declares com.lightningkite.khrysalis.net.HttpResponse
export let HttpResponse = Response;


//! Declares com.lightningkite.khrysalis.net.code
export function getOkhttp3ResponseCode(this_: HttpResponse): number { return this_.code(); }

//! Declares com.lightningkite.khrysalis.net.headers
export function getOkhttp3ResponseHeaders(this_: HttpResponse): Map<string, string> { return kotlinCollectionsMapMapValues(this_.headers().toMultimap(), (it) => kotlinCollectionsIterableJoinToString(it.value, ";", undefined, undefined, undefined, undefined, undefined)); }

//! Declares com.lightningkite.khrysalis.net.readText
export function okhttp3ResponseReadText(this_: HttpResponse): string{ return this_.body()!!.string(); }
//! Declares com.lightningkite.khrysalis.net.readJson
export function okhttp3ResponseReadJson<T>(this_: HttpResponse, T: any): T{
    let raw: (string | null) = null;
    
    try {
        raw = this_.okhttp3ResponseReadText();
        return comFasterxmlJacksonDatabindObjectMapperReadValue(HttpClient.INSTANCE.mapper[null], , raw);
    } catch(e: Exception){
        throw IllegalStateException.constructorkotlinString, kotlinThrowable(`Failed to parse '${raw}'`, e);
    };
}
//! Declares com.lightningkite.khrysalis.net.readJson
export function okhttp3ResponseReadJson<T>(this_: HttpResponse, T: any, typeToken: TypeReference<T>): T{
    let raw: (string | null) = null;
    
    try {
        raw = this_.okhttp3ResponseReadText();
        return HttpClient.INSTANCE.mapper.readValue<T>(raw, typeToken);
    } catch(e: Exception){
        throw IllegalStateException.constructorkotlinString, kotlinThrowable(`Failed to parse '${raw}'`, e);
    };
}


// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: net/HttpClient.actual.kt
// Package: com.lightningkite.khrysalis.net
// FQImport: com.lightningkite.khrysalis.net.HttpClient.go.result TS result
// FQImport: com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_IS_GETTERS TS AUTO_DETECT_IS_GETTERS
// FQImport: com.lightningkite.khrysalis.time.DateAlone.Companion.iso TS iso
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.qualityToTry TS qualityToTry
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.data TS data
// FQImport: com.fasterxml.jackson.databind.SerializerProvider TS SerializerProvider
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.<no name provided>.onResponse.response TS response
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<no name provided>.onResponse.<anonymous>.e TS e
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.<no name provided>.onResponse.response TS response
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<no name provided>.onFailure.e TS e
// FQImport: okhttp3.Response.code TS code
// FQImport: com.fasterxml.jackson.databind.DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE TS READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE
// FQImport: com.lightningkite.khrysalis.net.HttpClient.threadCorrectly.current TS current
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<no name provided>.onResponse.raw TS raw
// FQImport: okhttp3.MediaType TS MediaType
// FQImport: kotlin.ByteArray.size TS size
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.url TS url
// FQImport: com.fasterxml.jackson.databind.ObjectMapper.enable TS enable
// FQImport: android.util.Log.i TS i
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.body TS body
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<no name provided>.onResponse.response TS response
// FQImport: currentToken TS getComFasterxmlJacksonCoreJsonParserCurrentToken
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.<no name provided>.onResponse.raw TS raw
// FQImport: com.lightningkite.khrysalis.net.HttpClient.immediateMode TS immediateMode
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.url TS url
// FQImport: com.fasterxml.jackson.core.JsonToken TS JsonToken
// FQImport: android.graphics.Bitmap.CompressFormat.JPEG TS JPEG
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.onResult TS onResult
// FQImport: com.fasterxml.jackson.databind.PropertyNamingStrategy.SNAKE_CASE TS SNAKE_CASE
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.<no name provided>.onResponse.<anonymous>.code TS code
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.<anonymous>.result TS result
// FQImport: io.reactivex.schedulers.Schedulers TS Schedulers
// FQImport: com.lightningkite.khrysalis.time.TimeAlone TS TimeAlone
// FQImport: kotlin.Function3.invoke TS invoke
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.headers TS headers
// FQImport: android.util.Log.e TS e
// FQImport: com.lightningkite.khrysalis.net.HttpClient.threadCorrectly.T TS T
// FQImport: com.fasterxml.jackson.databind.ObjectMapper.setPropertyNamingStrategy TS setPropertyNamingStrategy
// FQImport: io.reactivex.Observable.observeOn TS observeOn
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.headers TS headers
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.data TS data
// FQImport: io.reactivex.Scheduler TS Scheduler
// FQImport: com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString TS writeValueAsString
// FQImport: java.io.ByteArrayOutputStream.toByteArray TS toByteArray
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.image TS image
// FQImport: com.fasterxml.jackson.databind.ObjectMapper.registerModule TS registerModule
// FQImport: okhttp3.Request.Builder.method TS method
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.headers TS headers
// FQImport: com.lightningkite.khrysalis.net.HttpClient._appContext TS _appContext
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.<no name provided>.onResponse.raw TS raw
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.request TS request
// FQImport: io.reactivex.android.schedulers.AndroidSchedulers TS AndroidSchedulers
// FQImport: okhttp3.RequestBody.create TS create
// FQImport: okhttp3.Callback.onFailure TS onFailure
// FQImport: okhttp3.Headers TS Headers
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.<anonymous>.sending TS sending
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.request TS request
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<no name provided>.onResponse.raw TS raw
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.<anonymous>.sending TS sending
// FQImport: com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES TS FAIL_ON_IGNORED_PROPERTIES
// FQImport: io.reactivex.android.schedulers.AndroidSchedulers.mainThread TS mainThread
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.headers TS headers
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.<anonymous>.it TS it
// FQImport: kotlin.Exception TS Exception
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.onResult TS onResult
// FQImport: okhttp3.MultipartBody.FORM TS FORM
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.<anonymous>.key TS key
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.image TS image
// FQImport: java.util.Locale.getDefault TS getDefault
// FQImport: com.fasterxml.jackson.core.Version TS Version
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.<no name provided>.onResponse.<anonymous>.code TS code
// FQImport: okhttp3.OkHttpClient TS OkHttpClient
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<anonymous>.key TS key
// FQImport: okhttp3.Call TS Call
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.additionalFields TS additionalFields
// FQImport: com.lightningkite.khrysalis.Image TS Image
// FQImport: kotlin.jvm.java TS getKotlinReflectKClassJava
// FQImport: com.fasterxml.jackson.databind.util.StdDateFormat TS StdDateFormat
// FQImport: com.lightningkite.khrysalis.net.HttpClient.mapper TS mapper
// FQImport: com.fasterxml.jackson.core.type.TypeReference TS TypeReference
// FQImport: com.fasterxml.jackson.databind.MapperFeature TS MapperFeature
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.fieldName TS fieldName
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.rawImage TS rawImage
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<anonymous>.it TS it
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<no name provided>.onResponse.response TS response
// FQImport: com.fasterxml.jackson.databind.ObjectMapper TS ObjectMapper
// FQImport: android.util.Log TS Log
// FQImport: android.os.Looper.getMainLooper TS getMainLooper
// FQImport: okhttp3.Request.Builder.build TS build
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.<no name provided>.onResponse.response TS response
// FQImport: okhttp3.Callback TS Callback
// FQImport: okhttp3.Call.execute TS execute
// FQImport: com.fasterxml.jackson.databind.util.StdDateFormat.withLenient TS withLenient
// FQImport: kotlin.io.use TS javaIoCloseableUse
// FQImport: okhttp3.Call.enqueue TS enqueue
// FQImport: com.lightningkite.khrysalis.net.HttpClient.mapper.<no name provided>.serialize.value TS value
// FQImport: com.lightningkite.khrysalis.time.iso8601 TS comLightningkiteKhrysalisTimeDateAloneIso8601
// FQImport: java.lang.Exception.printStackTrace TS printStackTrace
// FQImport: kotlin.Function2.invoke TS invoke
// FQImport: java.io.ByteArrayOutputStream TS ByteArrayOutputStream
// FQImport: com.fasterxml.jackson.databind.PropertyNamingStrategy TS PropertyNamingStrategy
// FQImport: android.os.Looper TS Looper
// FQImport: okhttp3.MultipartBody.Builder.setType TS setType
// FQImport: kotlin.collections.Map TS Map
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.method TS method
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.rawImage TS rawImage
// FQImport: com.lightningkite.khrysalis.net.HttpClient.go TS okhttp3CallGo
// FQImport: kotlin.Enum TS Enum
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.<no name provided>.onFailure.e TS e
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.<no name provided>.onFailure.e TS e
// FQImport: okhttp3.OkHttpClient.newCall TS newCall
// FQImport: com.fasterxml.jackson.databind.DeserializationFeature TS DeserializationFeature
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.url TS url
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.maxSize TS maxSize
// FQImport: com.lightningkite.khrysalis.net.HttpClient.go.callback TS callback
// FQImport: com.lightningkite.khrysalis.net.HttpClient.ioScheduler TS ioScheduler
// FQImport: com.fasterxml.jackson.core.JsonParser TS JsonParser
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.onResult TS onResult
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.request TS request
// FQImport: com.fasterxml.jackson.databind.ObjectMapper.disable TS disable
// FQImport: com.fasterxml.jackson.databind.module.SimpleModule TS SimpleModule
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.maxSize TS maxSize
// FQImport: okhttp3.MultipartBody.Builder.addFormDataPart TS addFormDataPart
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.method TS method
// FQImport: com.lightningkite.khrysalis.net.HttpClient.GET TS GET
// FQImport: com.lightningkite.khrysalis.net.HttpClient.go.e TS e
// FQImport: com.fasterxml.jackson.core.Version.unknownVersion TS unknownVersion
// FQImport: okhttp3.MultipartBody TS MultipartBody
// FQImport: okhttp3.MultipartBody.Builder.build TS build
// FQImport: com.fasterxml.jackson.core.JsonToken.VALUE_NULL TS VALUE_NULL
// FQImport: com.fasterxml.jackson.databind.deser.std.StdDeserializer TS StdDeserializer
// FQImport: okhttp3.RequestBody TS RequestBody
// FQImport: android.graphics.Bitmap TS Bitmap
// FQImport: com.lightningkite.khrysalis.time.TimeAlone.Companion.iso TS iso
// FQImport: com.lightningkite.khrysalis.net.HttpClient.runResult.action TS action
// FQImport: android.os.Handler.post TS post
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<no name provided>.onResponse.<anonymous>.read TS read
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.qualityToTry TS qualityToTry
// FQImport: com.fasterxml.jackson.module.kotlin.KotlinModule TS KotlinModule
// FQImport: okhttp3.Callback.onResponse TS onResponse
// FQImport: android.content.Context TS Context
// FQImport: com.lightningkite.khrysalis.net.HttpClient.responseScheduler TS responseScheduler
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.<anonymous>.value TS value
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.body TS body
// FQImport: io.reactivex.schedulers.Schedulers.io TS io
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.T TS T
// FQImport: com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES TS FAIL_ON_UNKNOWN_PROPERTIES
// FQImport: io.reactivex.Single.observeOn TS observeOn
// FQImport: text TS getComFasterxmlJacksonCoreJsonParserText
// FQImport: com.lightningkite.khrysalis.net.HttpResponse TS HttpResponse
// FQImport: java.io.IOException TS IOException
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<anonymous>.result TS result
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.<no name provided>.onResponse.<anonymous>.code TS code
// FQImport: okhttp3.Request.Builder.addHeader TS addHeader
// FQImport: com.fasterxml.jackson.databind.ObjectMapper.setDateFormat TS setDateFormat
// FQImport: com.fasterxml.jackson.core.JsonGenerator.writeString TS writeString
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.<no name provided>.onFailure.e TS e
// FQImport: com.fasterxml.jackson.core.JsonGenerator TS JsonGenerator
// FQImport: okhttp3.Request.Builder.url TS url
// FQImport: com.lightningkite.khrysalis.time.iso8601 TS comLightningkiteKhrysalisTimeTimeAloneIso8601
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<anonymous>.e TS e
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.fieldName TS fieldName
// FQImport: com.lightningkite.khrysalis.net.HttpClient.mapper.<no name provided>.serialize.gen TS gen
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<anonymous>.response TS response
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<anonymous>.it TS it
// FQImport: language TS getJavaUtilLocaleLanguage
// FQImport: okhttp3.Headers.of TS of
// FQImport: okhttp3.MediaType.parse TS parse
// FQImport: android.graphics.Bitmap.compress TS compress
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.<no name provided>.onResponse.raw TS raw
// FQImport: com.lightningkite.khrysalis.net.HttpBody TS HttpBody
// FQImport: android.os.Handler TS Handler
// FQImport: com.lightningkite.khrysalis.time.DateAlone TS DateAlone
// FQImport: com.lightningkite.khrysalis.net.HttpClient.threadCorrectly TS ioReactivexSingleThreadCorrectly
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.url TS url
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.request TS request
// FQImport: okhttp3.Request TS Request
// FQImport: java.lang.Exception.message TS message
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.headers TS headers
// FQImport: kotlin.Enum.name TS name
// FQImport: okhttp3.Request.Builder.headers TS headers
// FQImport: com.lightningkite.khrysalis.net.HttpClient.runResult TS runResult
// FQImport: okhttp3.Response.body TS body
// FQImport: java.io.IOException.message TS message
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<no name provided>.onFailure.e TS e
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.<anonymous>.it TS it
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.request TS request
// FQImport: com.lightningkite.khrysalis.loadImage TS loadImage
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<no name provided>.onResponse.<anonymous>.read TS read
// FQImport: com.fasterxml.jackson.databind.DeserializationContext TS DeserializationContext
// FQImport: okhttp3.ResponseBody.string TS string
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<no name provided>.onResponse.<anonymous>.code TS code
// FQImport: com.lightningkite.khrysalis.net.HttpClient.<set-appContext>.value TS value
// FQImport: java.util.Locale TS Locale
// FQImport: okhttp3.Response TS Response
// FQImport: com.fasterxml.jackson.databind.MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS TS ACCEPT_CASE_INSENSITIVE_ENUMS
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.<anonymous>.<anonymous>.it TS it
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<no name provided>.onResponse.<anonymous>.e TS e
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.T TS T
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callRaw.method TS method
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.method TS method
// FQImport: android.graphics.Bitmap.CompressFormat TS CompressFormat
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImage.<anonymous>.<anonymous>.value TS value
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.onResult TS onResult
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<anonymous>.emitter TS emitter
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<no name provided>.onResponse.<anonymous>.code TS code
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.url TS url
// FQImport: com.lightningkite.khrysalis.net.HttpClient.callWithoutResult.body TS body
// FQImport: com.fasterxml.jackson.databind.ObjectMapper.readValue TS readValue
// FQImport: com.fasterxml.jackson.databind.ser.std.StdSerializer TS StdSerializer
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.method TS method
// FQImport: okhttp3.OkHttpClient.Builder.build TS build
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.additionalFields TS additionalFields
// FQImport: com.lightningkite.khrysalis.net.HttpClient.mapper.<no name provided>.deserialize.p TS p
// FQImport: com.lightningkite.khrysalis.net.HttpClient.call.<anonymous>.sending TS sending
// FQImport: com.lightningkite.khrysalis.net.HttpClient.client TS client
// FQImport: com.fasterxml.jackson.core.JsonGenerator.writeNull TS writeNull
// FQImport: com.lightningkite.khrysalis.net.HttpClient.uploadImageWithoutResult.onResult TS onResult
import { TimeAlone } from './../time/TimeAlone.actual'
import { DateAlone, comLightningkiteKhrysalisTimeDateAloneIso8601, comLightningkiteKhrysalisTimeTimeAloneIso8601 } from './../time/DateAlone.actual'
import { HttpBody } from './HttpBody.actual'
import { HttpResponse } from './HttpResponse.actual'
import { Observable } from 'rxjs'
import { Image } from './../Image.shared'
import { loadImage } from './../Image.actual'

//! Declares com.lightningkite.khrysalis.net.HttpClient
export class HttpClient {
    private constructor() {
        this._appContext = null;
        this.ioScheduler = null;
        this.responseScheduler = null;
        this.GET = "GET";
        this.POST = "POST";
        this.PUT = "PUT";
        this.PATCH = "PATCH";
        this.DELETE = "DELETE";
        this.client = OkHttpClient.Builder.constructor().build();
        this.mapper = ObjectMapper.constructor()
        .registerModule(new KotlinModule(undefined, undefined, undefined))
        .registerModule(SimpleModule.constructorkotlinString, comfasterxmljacksoncoreVersion, kotlincollectionsMutableMap, kotlincollectionsMutableList("EnumFix", Version.unknownVersion(), new Map([[getKotlinReflectKClassJava(TimeAlone::class), new class Anon extends StdDeserializer<any> {
                                public constructor() {
                                    super(
                                        getKotlinReflectKClassJava(TimeAlone::class)
                                    );
                                }
                                
                                deserialize(p: JsonParser, ctxt: DeserializationContext): (TimeAlone | null){
                                    if (getComFasterxmlJacksonCoreJsonParserCurrentToken(p).equals(JsonToken.VALUE_NULL)) return null
                                    return TimeAlone.Companion.INSTANCE.iso(getComFasterxmlJacksonCoreJsonParserText(p));
                                }
                        }()], [getKotlinReflectKClassJava(DateAlone::class), new class Anon extends StdDeserializer<any> {
                                public constructor() {
                                    super(
                                        getKotlinReflectKClassJava(DateAlone::class)
                                    );
                                }
                                
                                deserialize(p: JsonParser, ctxt: DeserializationContext): (DateAlone | null){
                                    if (getComFasterxmlJacksonCoreJsonParserCurrentToken(p).equals(JsonToken.VALUE_NULL)) return null
                                    return DateAlone.Companion.INSTANCE.iso(getComFasterxmlJacksonCoreJsonParserText(p));
                                }
                }()]]), [new class Anon extends StdSerializer<any> {
                        public constructor() {
                            super(getKotlinReflectKClassJava(Enum::class));
                        }
                        
                        serialize(value: (Enum<*> | null), gen: JsonGenerator, provider: (SerializerProvider | null)){
                            if (value.equals(null)) {
                                gen.writeNull();
                            } else {
                                gen.writeString(value.name.toLowerCase());
                            }
                        }
                    }(), new class Anon extends StdSerializer<any> {
                        public constructor() {
                            super(getKotlinReflectKClassJava(TimeAlone::class));
                        }
                        
                        serialize(value: (TimeAlone | null), gen: JsonGenerator, provider: (SerializerProvider | null)){
                            if (value.equals(null)) {
                                gen.writeNull();
                            } else {
                                gen.writeString(comLightningkiteKhrysalisTimeTimeAloneIso8601(value));
                            }
                        }
                    }(), new class Anon extends StdSerializer<any> {
                        public constructor() {
                            super(getKotlinReflectKClassJava(DateAlone::class));
                        }
                        
                        serialize(value: (DateAlone | null), gen: JsonGenerator, provider: (SerializerProvider | null)){
                            if (value.equals(null)) {
                                gen.writeNull();
                            } else {
                                gen.writeString(comLightningkiteKhrysalisTimeDateAloneIso8601(value));
                            }
                        }
        }()]))
        .disable(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES)
        .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
        .enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS)
        .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)
        .enable(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)
        .setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE)
        .setDateFormat(StdDateFormat.constructor().withLenient(true));
        this.immediateMode = false;
    }
    public static INSTANCE = new HttpClient();
    
    
    private _appContext: (Context | null) = null;
    
    //! Declares com.lightningkite.khrysalis.net.HttpClient.appContext
    public get appContext(): Context { return this._appContext!!; }
    public set appContext(value: Context) {
        this._appContext = value;
        this.ioScheduler =  Schedulers.io();
        this.responseScheduler =  AndroidSchedulers.mainThread();
    }
    
    
    public ioScheduler: (Scheduler | null) = null;
    
    public responseScheduler: (Scheduler | null) = null;
    
    ioReactivexSingleThreadCorrectly<T>(this_: Observable<T>): Observable<T>{
        let current = this_;
        
        if(!(this.ioScheduler.equals(null))){
            current = current;
        }
        if(!(this.responseScheduler.equals(null))){
            current = current.observeOn(this.responseScheduler);
        }
        return current;
    }
    ioReactivexObservableThreadCorrectly<T>(this_: Observable<T>): Observable<T>{
        let current = this_;
        
        if(!(this.ioScheduler.equals(null))){
            current = current;
        }
        if(!(this.responseScheduler.equals(null))){
            current = current.observeOn(this.responseScheduler);
        }
        return current;
    }
    
    public readonly GET = "GET";
    
    public readonly POST = "POST";
    
    public readonly PUT = "PUT";
    
    public readonly PATCH = "PATCH";
    
    public readonly DELETE = "DELETE";
    
    
    public readonly client = OkHttpClient.Builder.constructor().build();
    
    public readonly mapper = ObjectMapper.constructor()
    .registerModule(new KotlinModule(undefined, undefined, undefined))
    .registerModule(SimpleModule.constructorkotlinString, comfasterxmljacksoncoreVersion, kotlincollectionsMutableMap, kotlincollectionsMutableList("EnumFix", Version.unknownVersion(), new Map([[getKotlinReflectKClassJava(TimeAlone::class), new class Anon extends StdDeserializer<any> {
                            public constructor() {
                                super(
                                    getKotlinReflectKClassJava(TimeAlone::class)
                                );
                            }
                            
                            deserialize(p: JsonParser, ctxt: DeserializationContext): (TimeAlone | null){
                                if (getComFasterxmlJacksonCoreJsonParserCurrentToken(p).equals(JsonToken.VALUE_NULL)) return null
                                return TimeAlone.Companion.INSTANCE.iso(getComFasterxmlJacksonCoreJsonParserText(p));
                            }
                    }()], [getKotlinReflectKClassJava(DateAlone::class), new class Anon extends StdDeserializer<any> {
                            public constructor() {
                                super(
                                    getKotlinReflectKClassJava(DateAlone::class)
                                );
                            }
                            
                            deserialize(p: JsonParser, ctxt: DeserializationContext): (DateAlone | null){
                                if (getComFasterxmlJacksonCoreJsonParserCurrentToken(p).equals(JsonToken.VALUE_NULL)) return null
                                return DateAlone.Companion.INSTANCE.iso(getComFasterxmlJacksonCoreJsonParserText(p));
                            }
            }()]]), [new class Anon extends StdSerializer<any> {
                    public constructor() {
                        super(getKotlinReflectKClassJava(Enum::class));
                    }
                    
                    serialize(value: (Enum<*> | null), gen: JsonGenerator, provider: (SerializerProvider | null)){
                        if (value.equals(null)) {
                            gen.writeNull();
                        } else {
                            gen.writeString(value.name.toLowerCase());
                        }
                    }
                }(), new class Anon extends StdSerializer<any> {
                    public constructor() {
                        super(getKotlinReflectKClassJava(TimeAlone::class));
                    }
                    
                    serialize(value: (TimeAlone | null), gen: JsonGenerator, provider: (SerializerProvider | null)){
                        if (value.equals(null)) {
                            gen.writeNull();
                        } else {
                            gen.writeString(comLightningkiteKhrysalisTimeTimeAloneIso8601(value));
                        }
                    }
                }(), new class Anon extends StdSerializer<any> {
                    public constructor() {
                        super(getKotlinReflectKClassJava(DateAlone::class));
                    }
                    
                    serialize(value: (DateAlone | null), gen: JsonGenerator, provider: (SerializerProvider | null)){
                        if (value.equals(null)) {
                            gen.writeNull();
                        } else {
                            gen.writeString(comLightningkiteKhrysalisTimeDateAloneIso8601(value));
                        }
                    }
    }()]))
    .disable(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES)
    .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
    .enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS)
    .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)
    .enable(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)
    .setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE)
    .setDateFormat(StdDateFormat.constructor().withLenient(true));
    
    
    call(
        url: string,
        method: string = HttpClient.INSTANCE.GET,
        headers: Map<string, string> = new Map([]),
        body: (HttpBody | null) = null
    ): Observable<HttpResponse>{
        const request = Request.Builder.constructor()
        .url(url)
        .method(method, body)
        .headers(Headers.of(headers))
        .addHeader("Accept-Language", getJavaUtilLocaleLanguage(Locale.getDefault()))
        .build();
        
        return this.ioReactivexSingleThreadCorrectly(new Observable<Response>((emitter) => try {
                    console.log(`Sending ${method} request to ${url} with headers ${headers}`);
                    const response = this.client.newCall(request).execute();
                    
                    console.log(`Response from ${method} request to ${url} with headers ${headers}: ${response.code()}`);
                    emitter.next(response); emitter.complete();
                } catch(e: Exception) {
                    emitter.error(e);
        }));
    }
    
    
    
    
    
    
    
    
    //YONDER LIES OLD CODE
    //Don't use these anymore.  Rx is better.
    
    
    
    
    public immediateMode = false;
    
    
    runResult(action: () => void){
        if (this.immediateMode) {
            this.action();
        } else {
            Handler.constructorandroidosLooper(Looper.getMainLooper()).post(() => this.action());
        }
    }
    
    okhttp3CallGo(this_: Call, callback: Callback){
        if (this.immediateMode) {
            try {
                const result = this_.execute();
                
                callback.onResponse(this_, result);
            } catch (e: IOException) {
                callback.onFailure(this_, e);
            };
        } else {
            this_.enqueue(callback);
        }
    }
    
    call<T extends any>(
        url: string,
        method: string,
        headers: Map<string, string>,
        body: (any | null) = null,
        onResult:  (code: number, result: (T | null), error: (string | null)) => void
    ){
        console.log(`Sending ${method} request to ${url} with headers ${headers}`);
        const request = Request.Builder.constructor()
        .url(url)
        .method(method, ((_it)=>{
                    if(_it === null) return null;
                    return ((it) => {
                            const sending = this.mapper.writeValueAsString(it);
                            
                            console.log(`with body ${sending}`);
                            return RequestBody.create(MediaType.parse("application/json"), sending);
                    })(_it)
        })(body))
        .headers(Headers.of(headers))
        .addHeader("Accept-Language", getJavaUtilLocaleLanguage(Locale.getDefault()))
        .build();
        
        
        this.okhttp3CallGo(this.client.newCall(request), new class Anon implements Callback {
                public static implementsInterfaceOkhttp3Callback = true;
                public constructor() {
                }
                
                onFailure(call: Call, e: IOException){
                    Log.e("HttpClient", `Failure: ${e.message}`);
                    this.runResult(() => onResult.invoke(0, null, e.message ?: ""));
                }
                
                onResponse(call: Call, response: Response){
                    const raw = response.body()!!.string();
                    
                    console.log(`Response ${response.code()}: ${raw}`);
                    this.runResult(() => {
                            const code = response.code();
                            
                            if (code / 100 === 2) {
                                try {
                                    const read = this.mapper.readValue<T>(raw, new class Anon extends TypeReference<any> {
                                            public constructor() {
                                                super();
                                            }
                                    }());
                                    
                                    onResult.invoke(code, read, null);
                                } catch (e: Exception) {
                                    Log.e("HttpClient", `Failure to parse: ${e.message}`);
                                    e.printStackTrace();
                                    onResult.invoke(code, null, e.message);
                                };
                            } else {
                                onResult.invoke(code, null, raw ?: "");
                            }
                    });
                }
        }());
    }
    
    callRaw(
        url: string,
        method: string,
        headers: Map<string, string>,
        body: (any | null) = null,
        onResult:  (code: number, result: (string | null), error: (string | null)) => void
    ){
        console.log(`Sending ${method} request to ${url} with headers ${headers}`);
        const request = Request.Builder.constructor()
        .url(url)
        .method(method, ((_it)=>{
                    if(_it === null) return null;
                    return ((it) => {
                            const sending = this.mapper.writeValueAsString(it);
                            
                            console.log(`with body ${sending}`);
                            return RequestBody.create(MediaType.parse("application/json"), sending);
                    })(_it)
        })(body))
        .headers(Headers.of(headers))
        .addHeader("Accept-Language", getJavaUtilLocaleLanguage(Locale.getDefault()))
        .build();
        
        
        this.okhttp3CallGo(this.client.newCall(request), new class Anon implements Callback {
                public static implementsInterfaceOkhttp3Callback = true;
                public constructor() {
                }
                
                onFailure(call: Call, e: IOException){
                    Log.e("HttpClient", `Failure: ${e.message}`);
                    this.runResult(() => onResult.invoke(0, null, e.message ?: ""));
                }
                
                onResponse(call: Call, response: Response){
                    const raw = response.body()!!.string();
                    
                    console.log(`Response ${response.code()}: ${raw}`);
                    this.runResult(() => {
                            const code = response.code();
                            
                            if (code / 100 === 2) {
                                onResult.invoke(code, raw, null);
                            } else {
                                onResult.invoke(code, null, raw ?: "");
                            }
                    });
                }
        }());
    }
    
    callWithoutResult(
        url: string,
        method: string,
        headers: Map<string, string>,
        body: (any | null) = null,
        onResult:  (code: number, error: (string | null)) => void
    ){
        console.log(`Sending ${method} request to ${url} with headers ${headers}`);
        const request = Request.Builder.constructor()
        .url(url)
        .method(method, ((_it)=>{
                    if(_it === null) return null;
                    return ((it) => {
                            const sending = this.mapper.writeValueAsString(it);
                            
                            console.log(`with body ${sending}`);
                            return RequestBody.create(MediaType.parse("application/json"), sending);
                    })(_it)
        })(body))
        .headers(Headers.of(headers))
        .addHeader("Accept-Language", getJavaUtilLocaleLanguage(Locale.getDefault()))
        .build();
        
        
        this.okhttp3CallGo(this.client.newCall(request), new class Anon implements Callback {
                public static implementsInterfaceOkhttp3Callback = true;
                public constructor() {
                }
                
                onFailure(call: Call, e: IOException){
                    Log.e("HttpClient", `Failure: ${e.message}`);
                    this.runResult(() => onResult.invoke(0, e.message ?: ""));
                }
                
                onResponse(call: Call, response: Response){
                    const raw = response.body()!!.string();
                    
                    console.log(`Response ${response.code()}: ${raw}`);
                    this.runResult(() => {
                            const code = response.code();
                            
                            if (code / 100 === 2) {
                                onResult.invoke(response.code(), null);
                            } else {
                                onResult.invoke(code, raw ?: "");
                            }
                    });
                }
        }());
    }
    
    uploadImageWithoutResult(
        url: string,
        method: string,
        headers: Map<string, string>,
        fieldName: string,
        image: Image,
        maxSize: number = 10_000_000,
        additionalFields: Map<string, string> = new Map([]),
        onResult:  (code: number, error: (string | null)) => void
    ){
        loadImage(image, (rawImage) => {
                if (rawImage.equals(null)) {
                    this.onResult(0, "Failed to read image.");
                    return;
                }
                let qualityToTry = 100;
                
                let data = javaIoCloseableUse(ByteArrayOutputStream.constructor(), (it) => {
                        rawImage.compress(Bitmap.CompressFormat.JPEG, qualityToTry, it);
                        return it.toByteArray();
                });
                
                while (data.size > maxSize) {
                    qualityToTry = qualityToTry - 5;
                    data = javaIoCloseableUse(ByteArrayOutputStream.constructor(), (it) => {
                            rawImage.compress(Bitmap.CompressFormat.JPEG, qualityToTry, it);
                            return it.toByteArray();
                    });
                }
                Log.i("HttpClient", `Sending ${method} request to ${url} with headers ${headers} and image at quality level ${qualityToTry}`);
                const request = Request.Builder.constructor()
                .url(url)
                .method(method, ((it) => {
                            let result = it;
                            
                            for (const toDestructure of additionalFields) {
                                const key = toDestructure[0]
                                const value = toDestructure[1]
                                
                                result = result.addFormDataPart(key, value)
                                
                            }
                            return result;
                    })(MultipartBody.Builder.constructor()
                        .setType(MultipartBody.FORM)
                    .addFormDataPart(fieldName, "image.jpg", RequestBody.create(MediaType.parse("image/jpeg"), data)))
                .build())
                .headers(Headers.of(headers))
                .build();
                
                
                this.okhttp3CallGo(this.client.newCall(request), new class Anon implements Callback {
                        public static implementsInterfaceOkhttp3Callback = true;
                        public constructor() {
                        }
                        
                        onFailure(call: Call, e: IOException){
                            this.runResult(() => onResult.invoke(0, e.message ?: ""));
                        }
                        
                        onResponse(call: Call, response: Response){
                            const raw = response.body()!!.string();
                            
                            console.log(`Response ${response.code()}: ${raw}`);
                            this.runResult(() => {
                                    const code = response.code();
                                    
                                    if (code / 100 === 2) {
                                        onResult.invoke(response.code(), null);
                                    } else {
                                        onResult.invoke(code, raw ?: "");
                                    }
                            });
                        }
                }());
        });
    }
    
    
    uploadImage<T extends any>(
        url: string,
        method: string,
        headers: Map<string, string>,
        fieldName: string,
        image: Image,
        maxSize: number = 10_000_000,
        additionalFields: Map<string, string> = new Map([]),
        onResult:  (code: number, result: (T | null), error: (string | null)) => void
    ){
        loadImage(image, (rawImage) => {
                if (rawImage.equals(null)) {
                    this.onResult(0, null, "Failed to read image.");
                    return;
                }
                let qualityToTry = 100;
                
                let data = javaIoCloseableUse(ByteArrayOutputStream.constructor(), (it) => {
                        rawImage.compress(Bitmap.CompressFormat.JPEG, qualityToTry, it);
                        return it.toByteArray();
                });
                
                while (data.size > maxSize) {
                    qualityToTry = qualityToTry - 5;
                    data = javaIoCloseableUse(ByteArrayOutputStream.constructor(), (it) => {
                            rawImage.compress(Bitmap.CompressFormat.JPEG, qualityToTry, it);
                            return it.toByteArray();
                    });
                }
                Log.i("HttpClient", `Sending ${method} request to ${url} with headers ${headers} and image at quality level ${qualityToTry}`);
                const request = Request.Builder.constructor()
                .url(url)
                .method(method, ((it) => {
                            let result = it;
                            
                            for (const toDestructure of additionalFields) {
                                const key = toDestructure[0]
                                const value = toDestructure[1]
                                
                                result = result.addFormDataPart(key, value)
                                
                            }
                            return result;
                    })(MultipartBody.Builder.constructor()
                        .setType(MultipartBody.FORM)
                    .addFormDataPart(fieldName, "image.jpg", RequestBody.create(MediaType.parse("image/jpeg"), data)))
                .build())
                .headers(Headers.of(headers))
                .build();
                
                
                this.okhttp3CallGo(this.client.newCall(request), new class Anon implements Callback {
                        public static implementsInterfaceOkhttp3Callback = true;
                        public constructor() {
                        }
                        
                        onFailure(call: Call, e: IOException){
                            this.runResult(() => onResult.invoke(0, null, e.message ?: ""));
                        }
                        
                        onResponse(call: Call, response: Response){
                            const raw = response.body()!!.string();
                            
                            console.log(`Response ${response.code()}: ${raw}`);
                            this.runResult(() => {
                                    const code = response.code();
                                    
                                    if (code / 100 === 2) {
                                        try {
                                            const read = this.mapper.readValue<T>(raw, new class Anon extends TypeReference<any> {
                                                    public constructor() {
                                                        super();
                                                    }
                                            }());
                                            
                                            onResult.invoke(code, read, null);
                                        } catch (e: Exception) {
                                            Log.e("HttpClient", `Failure to parse: ${e.message}`);
                                            onResult.invoke(code, null, e.message);
                                        };
                                    } else {
                                        onResult.invoke(code, null, raw ?: "");
                                    }
                            });
                        }
                }());
        });
    }
}



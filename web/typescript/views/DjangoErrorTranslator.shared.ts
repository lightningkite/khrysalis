// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: views/DjangoErrorTranslator.shared.kt
// Package: com.lightningkite.khrysalis.views
import { ViewString, ViewStringRaw, ViewStringResource } from './Strings.shared'
import { StringResource } from './ResourceTypes.actual'
import { KotlinStringFromJsonStringUntyped } from './../Codable.actual'
import { checkIsInterface } from 'khrysalis/dist/Kotlin'

//! Declares com.lightningkite.khrysalis.views.DjangoErrorTranslator
export class DjangoErrorTranslator {
    public readonly connectivityErrorResource: StringResource;
    public readonly serverErrorResource: StringResource;
    public readonly otherErrorResource: StringResource;
    public constructor( connectivityErrorResource: StringResource,  serverErrorResource: StringResource,  otherErrorResource: StringResource) {
        this.connectivityErrorResource = connectivityErrorResource;
        this.serverErrorResource = serverErrorResource;
        this.otherErrorResource = otherErrorResource;
    }
    
    
    public handleNode(builder: StringBuilder, node: (any | null)){
        if(node.equals(null)) return
        if(checkIsInterface(node, "KotlinCollectionsMap")){
            for (const toDestructure of node) {
                const key = toDestructure[0]
                const value = toDestructure[1]
                
                handleNode(builder, value)
                
            }
        }else if(checkIsInterface(node, "KotlinCollectionsList")){
            for (const value of node) {
                handleNode(builder, value);
            }
        }else if(typeof (node) == "string"){
            //Rough check for human-readability - sentences start with uppercase and will have spaces
            if(KotlinCharSequenceIsNotEmpty(node) && KotlinCharIsUpperCase(node.get(0)) && KotlinCharSequenceContains(node, " ", undefined)) {
                return JavaLangStringBuilderAppendln(builder, node);
            }
        };
    }
    public parseError(code: number, error: (string | null)): (ViewString | null){
        let resultError: (ViewString | null) = null;
        
        switch(code / 100){
            case 0:
            resultError = new ViewStringResource(this.connectivityErrorResource)
            break;
            case 1:
            case 2:
            case 3:
            
            break;
            case 4:
            const errorJson = error?.KotlinStringFromJsonStringUntyped();
            
            if(!(errorJson.equals(null))){
                const builder = StringBuilder.constructor();
                
                handleNode(builder, errorJson);
                resultError = new ViewStringRaw(builder.toString());
            } else {
                resultError = new ViewStringRaw(error ?: "");
            }
            break;
            case 5:
            resultError = new ViewStringResource(this.serverErrorResource)
            break;
            default:
            resultError = new ViewStringResource(this.otherErrorResource)
            break;
        }
        ;
        return resultError;
    }
    
    public wrap<T>(
        callback:  (result: (T | null), error: (ViewString | null)) => void
    ): (code: number, result: (T | null), error: (string | null)) => void{
        return (code, result, error) => this.callback(result, this.parseError(code, error));
    }
    
    public wrapNoResponse(
        callback:  (error: (ViewString | null)) => void
    ): (code: number, error: (string | null)) => void{
        return (code, error) => this.callback(this.parseError(code, error));
    }
    
}


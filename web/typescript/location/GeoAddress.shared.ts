// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: location/GeoAddress.shared.kt
// Package: com.lightningkite.khrysalis.location
import { hashString } from 'khrysalis/dist/Kotlin'
import { GeoCoordinate } from './GeoCoordinate.shared'
import { Codable } from './../Codable.actual'

//! Declares com.lightningkite.khrysalis.location.GeoAddress
export class GeoAddress implements Codable {
    public static implementsInterfaceComLightningkiteKhrysalisCodable = true;
    public readonly coordinate: (GeoCoordinate | null);
    public readonly name: (string | null);
    public readonly street: (string | null);
    public readonly subLocality: (string | null);
    public readonly locality: (string | null);
    public readonly subAdminArea: (string | null);
    public readonly adminArea: (string | null);
    public readonly countryName: (string | null);
    public readonly postalCode: (string | null);
    public constructor( coordinate: (GeoCoordinate | null) = null,  name: (string | null) = null,  street: (string | null) = null,  subLocality: (string | null) = null,  locality: (string | null) = null,  subAdminArea: (string | null) = null,  adminArea: (string | null) = null,  countryName: (string | null) = null,  postalCode: (string | null) = null) {
        this.coordinate = coordinate;
        this.name = name;
        this.street = street;
        this.subLocality = subLocality;
        this.locality = locality;
        this.subAdminArea = subAdminArea;
        this.adminArea = adminArea;
        this.countryName = countryName;
        this.postalCode = postalCode;
    }
    public hashCode(): number {
        let hash = 17;
        hash = 31 * hash + this.coordinate.hashCode();
        hash = 31 * hash + hashString(this.name);
        hash = 31 * hash + hashString(this.street);
        hash = 31 * hash + hashString(this.subLocality);
        hash = 31 * hash + hashString(this.locality);
        hash = 31 * hash + hashString(this.subAdminArea);
        hash = 31 * hash + hashString(this.adminArea);
        hash = 31 * hash + hashString(this.countryName);
        hash = 31 * hash + hashString(this.postalCode);
        return hash;
    }
    public equals(other: any): boolean { return other instanceof GeoAddress && this.coordinate.equals(other.coordinate) && this.name === other.name && this.street === other.street && this.subLocality === other.subLocality && this.locality === other.locality && this.subAdminArea === other.subAdminArea && this.adminArea === other.adminArea && this.countryName === other.countryName && this.postalCode === other.postalCode }
    public toString(): string { return `GeoAddress(coordinate = ${this.coordinate}, name = ${this.name}, street = ${this.street}, subLocality = ${this.subLocality}, locality = ${this.locality}, subAdminArea = ${this.subAdminArea}, adminArea = ${this.adminArea}, countryName = ${this.countryName}, postalCode = ${this.postalCode})` }
    public copy(coordinate: (GeoCoordinate | null) = this.coordinate, name: (string | null) = this.name, street: (string | null) = this.street, subLocality: (string | null) = this.subLocality, locality: (string | null) = this.locality, subAdminArea: (string | null) = this.subAdminArea, adminArea: (string | null) = this.adminArea, countryName: (string | null) = this.countryName, postalCode: (string | null) = this.postalCode) { return new GeoAddress(coordinate, name, street, subLocality, locality, subAdminArea, adminArea, countryName, postalCode); }
    
    public oneLine(withCountry: Boolean = false, withZip: Boolean = false): string{
        const builder = StringBuilder.constructor();
        
        this.street?.((it) => builder.append(it))(this);
        this.locality?.((it) => {
                builder.append(' ');
                builder.append(it);
        })(this);
        this.adminArea?.((it) => {
                builder.append(", ");
                builder.append(it);
        })(this);
        if (withCountry) {
            return this.adminArea?.((it) => {
                    builder.append(' ');
                    builder.append(it);
            })(this);
        }
        if (withZip) {
            return this.postalCode?.((it) => {
                    builder.append(' ');
                    builder.append(it);
            })(this);
        }
        return KotlinStringTrim(builder.toString());
    }
}


// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: observables/FlatMappedObservableProperty.shared.kt
// Package: com.lightningkite.khrysalis.observables
import { FlatMappedObservableProperty, MutableFlatMappedObservableProperty } from './FlatMappedObservableProperty.shared'
import { ObservableProperty } from './ObservableProperty.shared'
import { getComLightningkiteKhrysalisObservablesObservablePropertyObservable } from './ObservableProperty.ext.shared'
import { Box } from './../Box.actual'
import { Observable } from 'rxjs'
import { MutableObservableProperty } from './MutableObservableProperty.shared'
import { switchMap } from 'rxjs/operators as rxSwitchMap'

//! Declares com.lightningkite.khrysalis.observables.FlatMappedObservableProperty
export class FlatMappedObservableProperty<A, B> extends ObservableProperty<any> {
    public readonly basedOn: ObservableProperty<A>;
    public readonly transformation:  (a: A) => ObservableProperty<B>;
    public constructor( basedOn: ObservableProperty<A>,  transformation:  (a: A) => ObservableProperty<B>) {
        super();
        this.basedOn = basedOn;
        this.transformation = transformation;
    }
    
    //! Declares com.lightningkite.khrysalis.observables.FlatMappedObservableProperty.value
    public get value(): B { return transformation(basedOn.value).value; }
    
    //! Declares com.lightningkite.khrysalis.observables.FlatMappedObservableProperty.onChange
    public get onChange(): Observable<Box<B>> { return rxSwitchMap((it) => getComLightningkiteKhrysalisObservablesObservablePropertyObservable(this.transformation(it.value)))(getComLightningkiteKhrysalisObservablesObservablePropertyObservable(basedOn)).skip(1); }
    
}

//! Declares com.lightningkite.khrysalis.observables.flatMap
export function ComLightningkiteKhrysalisObservablesObservablePropertyFlatMap<T, B>(this_FlatMap: ObservableProperty<T>, transformation:  (a: T) => ObservableProperty<B>): FlatMappedObservableProperty<T, B>{
    return new FlatMappedObservableProperty<T, B>(this_FlatMap, transformation);
}

//! Declares com.lightningkite.khrysalis.observables.MutableFlatMappedObservableProperty
export class MutableFlatMappedObservableProperty<A, B> extends MutableObservableProperty<any> {
    public readonly basedOn: ObservableProperty<A>;
    public readonly transformation:  (a: A) => MutableObservableProperty<B>;
    public constructor( basedOn: ObservableProperty<A>,  transformation:  (a: A) => MutableObservableProperty<B>) {
        super();
        this.basedOn = basedOn;
        this.transformation = transformation;
        this.lastProperty = null;
    }
    
    //! Declares com.lightningkite.khrysalis.observables.MutableFlatMappedObservableProperty.value
    public get value(): B { return transformation(basedOn.value).value; }
    public set value(value: B) {
        transformation(basedOn.value).value = value;
    }
    
    
    public lastProperty: (MutableObservableProperty<B> | null) = null;
    
    
    //! Declares com.lightningkite.khrysalis.observables.MutableFlatMappedObservableProperty.onChange
    public get onChange(): Observable<Box<B>> { return rxSwitchMap( (it: Box<A>) => {
                const prop = this.transformation(it.value);
                
                this.lastProperty = prop;
                return getComLightningkiteKhrysalisObservablesObservablePropertyObservable(prop);
    })(getComLightningkiteKhrysalisObservablesObservablePropertyObservable(basedOn)).skip(1); }
    
    
    public update(){
        this.lastProperty?.update();
    }
}

//! Declares com.lightningkite.khrysalis.observables.flatMapMutable
export function ComLightningkiteKhrysalisObservablesObservablePropertyFlatMapMutable<T, B>(this_FlatMapMutable: ObservableProperty<T>, transformation:  (a: T) => MutableObservableProperty<B>): MutableFlatMappedObservableProperty<T, B>{
    return new MutableFlatMappedObservableProperty<T, B>(this_FlatMapMutable, transformation);
}


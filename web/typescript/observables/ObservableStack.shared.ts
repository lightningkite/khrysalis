// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: observables/ObservableStack.shared.kt
// Package: com.lightningkite.khrysalis.observables
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.onChange TS onChange
// FQImport: kotlin.Boolean TS Boolean
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.stack TS stack
// FQImport: java.util.ArrayList.isEmpty TS isEmpty
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.T TS T
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo.found TS found
// FQImport: io.reactivex.subjects.PublishSubject.onNext TS onNext
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.push.t TS t
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo.predicate TS predicate
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.Companion.withFirst.value TS value
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack SKIPPED due to same file
// FQImport: java.util.ArrayList.clear TS clear
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.reset.t TS t
// FQImport: com.lightningkite.khrysalis.Box TS Box
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo.t TS t
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.swap.t TS t
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack TS ObservableStack
// FQImport: com.lightningkite.khrysalis.boxWrap TS boxWrap
// FQImport: com.lightningkite.khrysalis.observables.ObservableProperty TS ObservableProperty
// FQImport: java.util.ArrayList.add TS add
// FQImport: java.util.ArrayList.size TS size
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo TS popTo
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo.i TS i
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.Companion.withFirst.T TS T
// FQImport: io.reactivex.subjects.PublishSubject TS PublishSubject
// FQImport: io.reactivex.subjects.PublishSubject.create TS create
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.Companion.withFirst.result TS result
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.reset TS reset
import { ObservableProperty } from './ObservableProperty.shared'
import { NumberRange } from 'khrysalis/dist/Kotlin'

//! Declares com.lightningkite.khrysalis.observables.ObservableStack
export class ObservableStack<T extends object> extends ObservableProperty<any> {
    constructor() { super(); }
    
    public static Companion = class Companion {
        private constructor() {
        }
        public static INSTANCE = new Companion();
        
        public withFirst<T extends object>(value: T): ObservableStack<T>{
            const result = new ObservableStack<T>();
            
            result.reset(value);
            return result;
        }
    }
    
    public readonly onChange: PublishSubject<Box<Array<T>>> = PublishSubject.create();
    
    //! Declares com.lightningkite.khrysalis.observables.ObservableStack.value
    public get value(): Array<T> { return {
            return this.stack;
    }; }{
        return this.stack;
    }
    
    
    public readonly stack: Array<T> = [];
    
    
    public push(t: T){
        this.stack.add(t);
        this.onChange.onNext(boxWrap(this.stack));
    }
    
    public swap(t: T){
        this.stack.splice((this.stack.length - 1), 1);
        this.stack.add(t);
        this.onChange.onNext(boxWrap(this.stack));
    }
    
    public pop(): Boolean{
        (() => {if (this.stack.size <= 1) {
                    return false;
        }})()
        this.stack.splice((this.stack.length - 1), 1);
        this.onChange.onNext(boxWrap(this.stack));
        return true;
    }
    
    public dismiss(): Boolean{
        (() => {if (this.stack.isEmpty()) {
                    return false;
        }})()
        this.stack.splice((this.stack.length - 1), 1);
        this.onChange.onNext(boxWrap(this.stack));
        return true;
    }
    
    public popTo(t: T){
        let found = false;
        
        for (const i of new NumberRange(0, (this.stack.length - 1))) {
            return (() => {if (found) {
                        return this.stack.splice((this.stack.length - 1), 1);
                    } else if (this.stack[i] === t) {
                        found = true;
            }})()
        }
        this.onChange.onNext(boxWrap(this.stack));
    }
    
    public popTo(predicate: (a: T) => Boolean){
        let found = false;
        
        for (const i of new NumberRange(0, (this.stack.length - 1))) {
            return (() => {if (found) {
                        return this.stack.splice((this.stack.length - 1), 1);
                    } else if (this.predicate(this.stack[i])) {
                        found = true;
            }})()
        }
        this.onChange.onNext(boxWrap(this.stack));
    }
    
    public root(){
        popTo(this.stack[0]);
    }
    
    public reset(t: T){
        this.stack.clear();
        this.stack.add(t);
        this.onChange.onNext(boxWrap(this.stack));
    }
}


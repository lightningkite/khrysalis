// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: observables/ObservableStack.shared.kt
// Package: com.lightningkite.khrysalis.observables
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.onChange TS onChange
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.swap.t TS t
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.stack TS stack
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.T TS T
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack TS ObservableStack
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo.found TS found
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.push.t TS t
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo.predicate TS predicate
// FQImport: com.lightningkite.khrysalis.observables.ObservableProperty TS ObservableProperty
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.Companion.withFirst.value TS value
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo TS popTo
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack SKIPPED due to same file
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo.i TS i
// FQImport: java.util.ArrayList.clear TS clear
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.Companion.withFirst.T TS T
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.Companion.withFirst.result TS result
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.reset.t TS t
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.reset TS reset
// FQImport: com.lightningkite.khrysalis.observables.ObservableStack.popTo.t TS t
import { ObservableProperty } from './ObservableProperty.shared'
import { Subject } from 'rxjs'
import { NumberRange } from 'Kotlin'

//! Declares com.lightningkite.khrysalis.observables.ObservableStack
export class ObservableStack<T extends object> extends ObservableProperty<any> {
    public constructor() { super(); }
    
    public static Companion = class Companion {
        private constructor() {
        }
        public static INSTANCE = new Companion();
        
        public withFirst<T extends object>(value: T): ObservableStack<T>{
            const result = new ObservableStack<T>();
            
            result.reset(value);
            return result;
        }
    }
    
    public readonly onChange: Subject<Array<T>>;
    
    //! Declares com.lightningkite.khrysalis.observables.ObservableStack.value
    public get value(): Array<T> {
        return this.stack;
    }
    
    
    public readonly stack: Array<T>;
    
    
    public push(t: T): void{
        this.stack.push(t);
        this.onChange.next(this.stack);
    }
    
    public swap(t: T): void{
        this.stack.splice((this.stack.length - 1), 1);
        this.stack.push(t);
        this.onChange.next(this.stack);
    }
    
    public pop(): boolean{
        if (this.stack.length <= 1) {
            return false;
        }
        this.stack.splice((this.stack.length - 1), 1);
        this.onChange.next(this.stack);
        return true;
    }
    
    public dismiss(): boolean{
        if (this.stack.length === 0) {
            return false;
        }
        this.stack.splice((this.stack.length - 1), 1);
        this.onChange.next(this.stack);
        return true;
    }
    
    public popTo(t: T): void{
        let found = false;
        
        for (const i of new NumberRange(0, (this.stack.length - 1))) {
            if (found) {
                this.stack.splice((this.stack.length - 1), 1);
            } else if (this.stack[i] === t) {
                found = true;
            }
        }
        this.onChange.next(this.stack);
    }
    
    public popTo(predicate: (a: T) => boolean): void{
        let found = false;
        
        for (const i of new NumberRange(0, (this.stack.length - 1))) {
            if (found) {
                this.stack.splice((this.stack.length - 1), 1);
            } else if (predicate(this.stack[i])) {
                found = true;
            }
        }
        this.onChange.next(this.stack);
    }
    
    public root(): void{
        this.popTo(this.stack[0]);
    }
    
    public reset(t: T): void{
        this.stack.clear();
        this.stack.push(t);
        this.onChange.next(this.stack);
    }
}


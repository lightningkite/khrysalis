// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: observables/ObservableStack.shared.kt
// Package: com.lightningkite.khrysalis.observables
import { ObservableProperty } from './ObservableProperty.shared'
import { ObservableStack } from './ObservableStack.shared'
import { Box, boxWrap } from './../Box.actual'
import { NumberRange } from 'khrysalis/dist/Kotlin'

//! Declares com.lightningkite.khrysalis.observables.ObservableStack
export class ObservableStack<T extends object> extends ObservableProperty<any> {
    constructor() { super(); }
    
    public static Companion = class Companion {
        private constructor() {
        }
        public static INSTANCE = new Companion();
        
        public withFirst<T extends object>(value: T): ObservableStack<T>{
            const result = new ObservableStack<T>();
            
            result.reset(value);
            return result;
        }
    }
    
    public readonly onChange: PublishSubject<Box<Array<T>>> = PublishSubject.create();
    
    //! Declares com.lightningkite.khrysalis.observables.ObservableStack.value
    public get value(): Array<T> { return {
            return this.stack;
    }; }{
        return this.stack;
    }
    
    
    public readonly stack: Array<T> = [];
    
    
    public push(t: T){
        stack.add(t);
        onChange.onNext(boxWrap(this.stack));
    }
    
    public swap(t: T){
        stack.splice((stack.length - 1), 1);
        stack.add(t);
        onChange.onNext(boxWrap(this.stack));
    }
    
    public pop(): Boolean{
        if (stack.size <= 1) {
            return false;
        }
        stack.splice((stack.length - 1), 1);
        onChange.onNext(boxWrap(this.stack));
        return true;
    }
    
    public dismiss(): Boolean{
        if (stack.isEmpty()) {
            return false;
        }
        stack.splice((stack.length - 1), 1);
        onChange.onNext(boxWrap(this.stack));
        return true;
    }
    
    public popTo(t: T){
        let found = false;
        
        for (const i of new NumberRange(0, (stack.length - 1))) {
            return if (found) {
                return stack.splice((stack.length - 1), 1);
            } else if (this.stack[i] === t) {
                found = true;
            }
        }
        onChange.onNext(boxWrap(this.stack));
    }
    
    public popTo(predicate: (a: T) => Boolean){
        let found = false;
        
        for (const i of new NumberRange(0, (stack.length - 1))) {
            return if (found) {
                return stack.splice((stack.length - 1), 1);
            } else if (this.predicate(this.stack[i])) {
                found = true;
            }
        }
        onChange.onNext(boxWrap(this.stack));
    }
    
    public root(){
        popTo(stack[0]);
    }
    
    public reset(t: T){
        stack.clear();
        stack.add(t);
        onChange.onNext(boxWrap(this.stack));
    }
}


// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: bytes/ByteBuffer.actual.kt
// Package: com.lightningkite.khrysalis.bytes
// FQImport: java.nio.ByteBuffer.wrap TS wrap
// FQImport: java.nio.ByteBuffer.get TS get
// FQImport: kotlin.text.take TS kotlinStringTake
// FQImport: java.nio.ByteBuffer.put TS put
// FQImport: com.lightningkite.khrysalis.bytes.getUtf8.index TS index
// FQImport: com.lightningkite.khrysalis.bytes.getUtf8.beforePosition TS beforePosition
// FQImport: kotlin.text.Charsets.UTF_8 TS UTF_8
// FQImport: kotlin.text.toByteArray TS kotlinStringToByteArray
// FQImport: com.lightningkite.khrysalis.bytes.putUtf8.beforePosition TS beforePosition
// FQImport: java.nio.ByteBuffer.getShort TS getShort
// FQImport: com.lightningkite.khrysalis.bytes.putUtf8.index TS index
// FQImport: kotlin.ByteArray TS ByteArray
// FQImport: kotlin.String.length TS length
// FQImport: com.lightningkite.khrysalis.bytes.getSetSizeUtf8.byteArray TS byteArray
// FQImport: com.lightningkite.khrysalis.bytes.putSetSizeUtf8.index TS index
// FQImport: java.nio.ByteBuffer.putShort TS putShort
// FQImport: com.lightningkite.khrysalis.bytes.putSetSizeUtf8.string TS string
// FQImport: com.lightningkite.khrysalis.bytes.putSetSizeUtf8.beforePosition TS beforePosition
// FQImport: java.nio.ByteBuffer.array TS array
// FQImport: kotlin.collections.toString TS kotlinByteArrayToString
// FQImport: com.lightningkite.khrysalis.bytes.putSetSizeUtf8.length TS length
// FQImport: com.lightningkite.khrysalis.bytes.putUtf8.string TS string
// FQImport: com.lightningkite.khrysalis.bytes.getUtf8.byteArray TS byteArray
// FQImport: java.nio.ByteBuffer.position TS position
// FQImport: com.lightningkite.khrysalis.bytes.getSetSizeUtf8.beforePosition TS beforePosition
// FQImport: com.lightningkite.khrysalis.bytes.getSetSizeUtf8.index TS index
// FQImport: com.lightningkite.khrysalis.bytes.Data TS Data
// FQImport: com.lightningkite.khrysalis.bytes.getUtf8.length TS length
// FQImport: com.lightningkite.khrysalis.bytes.getSetSizeUtf8.length TS length
// FQImport: java.nio.ByteBuffer TS ByteBuffer
import { Data } from './Data.actual'

//! Declares com.lightningkite.khrysalis.bytes.buffer
export function kotlinByteArrayBuffer(this_: Data): ByteBuffer{
    return ByteBuffer.wrap(this_);
}

//! Declares com.lightningkite.khrysalis.bytes.data
export function javaNioByteBufferData(this_: ByteBuffer): Data{ return this_.array(); }

//! Declares com.lightningkite.khrysalis.bytes.getUtf8
export function javaNioByteBufferGetUtf8(this_: ByteBuffer): string{
    const length = this_.getShort();
    
    const byteArray = new ByteArray(length);
    
    this_.get(byteArray);
    return kotlinByteArrayToString(byteArray, Charsets.INSTANCE.UTF_8);
}

//! Declares com.lightningkite.khrysalis.bytes.getUtf8
export function javaNioByteBufferGetUtf8(this_: ByteBuffer, index: number): string{
    const beforePosition = this_.position();
    
    this_.position(index);
    const length = this_.getShort();
    
    const byteArray = new ByteArray(length);
    
    this_.get(byteArray);
    this_.position(beforePosition);
    return kotlinByteArrayToString(byteArray, Charsets.INSTANCE.UTF_8);
}

//! Declares com.lightningkite.khrysalis.bytes.putUtf8
export function javaNioByteBufferPutUtf8(this_: ByteBuffer, string: string): ByteBuffer{
    this_.putShort(string.length);
    this_.put(kotlinStringToByteArray(string, Charsets.INSTANCE.UTF_8));
    return this_;
}

//! Declares com.lightningkite.khrysalis.bytes.putUtf8
export function javaNioByteBufferPutUtf8(this_: ByteBuffer, index: number, string: string): ByteBuffer{
    const beforePosition = this_.position();
    
    this_.position(index);
    this_.putShort(string.length);
    this_.put(kotlinStringToByteArray(string, Charsets.INSTANCE.UTF_8));
    this_.position(beforePosition);
    return this_;
}

//! Declares com.lightningkite.khrysalis.bytes.getSetSizeUtf8
export function javaNioByteBufferGetSetSizeUtf8(this_: ByteBuffer, length: number): string{
    const byteArray = new ByteArray(length);
    
    this_.get(byteArray);
    return kotlinByteArrayToString(byteArray, Charsets.INSTANCE.UTF_8);
}

//! Declares com.lightningkite.khrysalis.bytes.getSetSizeUtf8
export function javaNioByteBufferGetSetSizeUtf8(this_: ByteBuffer, length: number, index: number): string{
    const beforePosition = this_.position();
    
    this_.position(index);
    const byteArray = new ByteArray(length);
    
    this_.get(byteArray);
    this_.position(beforePosition);
    return kotlinByteArrayToString(byteArray, Charsets.INSTANCE.UTF_8);
}

//! Declares com.lightningkite.khrysalis.bytes.putSetSizeUtf8
export function javaNioByteBufferPutSetSizeUtf8(this_: ByteBuffer, length: number, string: string): ByteBuffer{
    this_.put(kotlinStringToByteArray(kotlinStringTake(string, length).padEnd(length, '\u0000'), Charsets.INSTANCE.UTF_8));
    return this_;
}

//! Declares com.lightningkite.khrysalis.bytes.putSetSizeUtf8
export function javaNioByteBufferPutSetSizeUtf8(this_: ByteBuffer, length: number, index: number, string: string): ByteBuffer{
    const beforePosition = this_.position();
    
    this_.position(index);
    this_.put(kotlinStringToByteArray(kotlinStringTake(string, length).padEnd(length, '\u0000'), Charsets.INSTANCE.UTF_8));
    this_.position(beforePosition);
    return this_;
}

/* SHARED DECLARATIONS

class ByteBuffer : Comparable<ByteBuffer> {
    
    open fun put(src: ByteBuffer): ByteBuffer
    
    open fun put(
        src: Data, offset: Int,
        length: Int
    ): ByteBuffer
    
    fun put(src: Data): ByteBuffer
    
    fun hasArray(): Boolean
    
    fun array(): Data
    
    fun arrayOffset(): Int
    
    fun position(newPosition: Int): Buffer
    
    fun limit(newLimit: Int): Buffer
    
    fun mark(): Buffer
    
    fun reset(): Buffer
    
    fun clear(): Buffer
    
    fun flip(): Buffer
    
    fun rewind(): Buffer
    
    fun compact(): ByteBuffer
    
    fun order(): ByteOrder
    
    fun order(bo: ByteOrder): ByteBuffer
    
    fun get(): Byte
    fun put(b: Byte): ByteBuffer
    
    operator fun get(i: Int): Byte
    fun put(i: Int, b: Byte): ByteBuffer
    
    fun getShort(): Short
    fun putShort(i: Short): ByteBuffer
    
    fun getShort(i: Int): Short
    fun putShort(i: Int, i1: Short): ByteBuffer
    
    fun getInt(): Int
    fun putInt(i: Int): ByteBuffer
    
    fun getInt(i: Int): Int
    fun putInt(i: Int, i1: Int): ByteBuffer
    
    fun getLong(): Long
    fun putLong(l: Long): ByteBuffer
    
    fun getLong(i: Int): Long
    fun putLong(i: Int, l: Long): ByteBuffer
    
    fun getFloat(): Float
    fun putFloat(v: Float): ByteBuffer
    
    fun getFloat(i: Int): Float
    fun putFloat(i: Int, v: Float): ByteBuffer
    
    fun getDouble(): Double
    fun putDouble(v: Double): ByteBuffer
    
    fun getDouble(i: Int): Double
    fun putDouble(i: Int, v: Double): ByteBuffer
    
    companion object {
        fun allocateDirect(capacity: Int): ByteBuffer {}
        
        fun allocate(capacity: Int): ByteBuffer {}
        
        fun wrap(
            array: Data,
            offset: Int,
            length: Int
        ): ByteBuffer {}
        
        fun wrap(array: Data): ByteBuffer {}
    }
}

enum class ByteOrder {
    BIG_ENDIAN,
    LITTLE_ENDIAN
}

*/



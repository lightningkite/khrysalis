import { countdown as rawCountdown, countup as rawCountup, range as rawRange, consume as rawConsume, each as rawEach, every as rawEvery, first as rawFirst, includes as rawIncludes, match as rawMatch, reduce as rawReduce, some as rawSome, last as rawLast, toArray as rawToArray, toSet as rawToSet } from "iterable-operator";
export declare let chunkBy: <T>(iterable: Iterable<T>, fn: (element: T, index: number) => boolean) => Iterable<T[]>;
export declare let chunk: <T>(iterable: Iterable<T>, size: number) => Iterable<T[]>;
export declare let concat: <T1, T2>(iterable1: Iterable<T1>, iterable2: Iterable<T2>) => Iterable<T1 | T2>;
export declare let dropRight: <T>(iterable: Iterable<T>, count: number) => Iterable<T>;
export declare let dropUntil: <T>(iterable: Iterable<T>, fn: (element: T, index: number) => boolean) => Iterable<T>;
export declare let drop: <T>(iterable: Iterable<T>, count: number) => Iterable<T>;
export declare let filter: <T, U extends T = T>(iterable: Iterable<T>, fn: (element: T, index: number) => boolean) => Iterable<U>;
export declare let flattenBy: (iterable: Iterable<unknown>, fn: (element: unknown, level: number) => boolean) => Iterable<any>;
export declare let flattenDeep: <T>(iterable: Iterable<unknown>, depth: number) => Iterable<T>;
export declare let flatten: <T>(iterable: Iterable<unknown>) => Iterable<T>;
export declare let map: <T, U>(iterable: Iterable<T>, fn: (element: T, index: number) => U) => Iterable<U>;
export declare let repeat: <T>(iterable: Iterable<T>, times: number) => Iterable<T>;
export declare let slice: <T>(iterable: Iterable<T>, start: number, end: number) => Iterable<T>;
export declare let splitBy: <T>(iterable: Iterable<T>, fn: (element: T, index: number) => boolean) => Iterable<T[]>;
export declare let split: <T>(iterable: Iterable<T>, separator: T) => Iterable<T[]>;
export declare let takeRight: <T>(iterable: Iterable<T>, count: number) => Iterable<T>;
export declare let takeUntil: <T>(iterable: Iterable<T>, fn: (element: T, index: number) => boolean) => Iterable<T>;
export declare let take: <T>(iterable: Iterable<T>, count: number) => Iterable<T>;
export declare let tap: <T>(iterable: Iterable<T>, fn: (element: T, index: number) => unknown) => Iterable<T>;
export declare let transform: <T, U>(iterable: Iterable<T>, transformer: (iterable: Iterable<T>) => Iterable<U>) => Iterable<U>;
export declare let uniqBy: <T, U>(iterable: Iterable<T>, fn: (element: T, index: number) => U) => Iterable<T>;
export declare let uniq: <T>(iterable: Iterable<T>) => Iterable<T>;
export declare let zip: <T1, T2>(iterable1: Iterable<T1>, iterable2: Iterable<T2>) => Iterable<Array<T1 | T2>>;
export declare let countdown: typeof rawCountdown;
export declare let countup: typeof rawCountup;
export declare let range: typeof rawRange;
export declare let consume: typeof rawConsume;
export declare let each: typeof rawEach;
export declare let every: typeof rawEvery;
export declare function find<T>(iter: Iterable<T>, predicate: (item: T) => boolean): T | null;
export declare let first: typeof rawFirst;
export declare let includes: typeof rawIncludes;
export declare let match: typeof rawMatch;
export declare let reduce: typeof rawReduce;
export declare let some: typeof rawSome;
export declare let last: typeof rawLast;
export declare let toArray: typeof rawToArray;
export declare let toSet: typeof rawToSet;

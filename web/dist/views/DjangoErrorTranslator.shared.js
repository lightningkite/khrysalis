"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: views/DjangoErrorTranslator.shared.kt
// Package: com.lightningkite.khrysalis.views
const Strings_shared_1 = require("./Strings.shared");
const kotlin_text_1 = require("../kotlin/kotlin.text");
const kotlin_text_2 = require("../kotlin/kotlin.text");
const Codable_actual_1 = require("../Codable.actual");
const Kotlin_1 = require("../Kotlin");
//! Declares com.lightningkite.khrysalis.views.DjangoErrorTranslator
class DjangoErrorTranslator {
    constructor(connectivityErrorResource, serverErrorResource, otherErrorResource) {
        this.connectivityErrorResource = connectivityErrorResource;
        this.serverErrorResource = serverErrorResource;
        this.otherErrorResource = otherErrorResource;
    }
    handleNode(builder, node) {
        if (node === null) {
            return;
        }
        if (Kotlin_1.checkIsInterface(node, "KotlinCollectionsMap")) {
            for (const toDestructure of node) {
                const key = toDestructure[0];
                const value = toDestructure[1];
                this.handleNode(builder, value);
            }
        }
        else if (Kotlin_1.checkIsInterface(node, "KotlinCollectionsList")) {
            for (const value of node) {
                this.handleNode(builder, value);
            }
        }
        else if (typeof (node) == "string") {
            //Rough check for human-readability - sentences start with uppercase and will have spaces
            if (node !== "" && kotlin_text_2.kotlinCharIsUpperCase(node[0]) && (node.indexOf(" ") != -1)) {
                builder.value += node + '\n';
            }
        }
    }
    parseError(code, error) {
        let resultError = null;
        switch (code / 100) {
            case 0:
                resultError = new Strings_shared_1.ViewStringResource(this.connectivityErrorResource);
                break;
            case 1:
            case 2:
            case 3:
                break;
            case 4:
                const errorJson = (() => {
                    if (error !== null) {
                        Codable_actual_1.kotlinStringFromJsonStringUntyped(error);
                    }
                    else {
                        return null;
                    }
                })();
                if (errorJson !== null) {
                    const builder = new kotlin_text_1.StringBuilder();
                    this.handleNode(builder, errorJson);
                    resultError = new Strings_shared_1.ViewStringRaw(builder.toString());
                }
                else {
                    resultError = new Strings_shared_1.ViewStringRaw(error !== null && error !== void 0 ? error : "");
                }
                break;
            case 5:
                resultError = new Strings_shared_1.ViewStringResource(this.serverErrorResource);
                break;
            default:
                resultError = new Strings_shared_1.ViewStringResource(this.otherErrorResource);
                break;
        }
        return resultError;
    }
    wrap(callback) {
        return (code, result, error) => {
            callback(result, this.parseError(code, error));
        };
    }
    wrapNoResponse(callback) {
        return (code, error) => {
            callback(this.parseError(code, error));
        };
    }
}
exports.DjangoErrorTranslator = DjangoErrorTranslator;
//# sourceMappingURL=DjangoErrorTranslator.shared.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: views/geometry/PolygonF.shared.kt
// Package: com.lightningkite.khrysalis.views.geometry
const Collections_1 = require("../../kotlin/Collections");
const Kotlin_1 = require("../../Kotlin");
const iterable_operator_1 = require("iterable-operator");
const Geometry_shared_1 = require("./Geometry.shared");
//! Declares com.lightningkite.khrysalis.views.geometry.PolygonF
class PolygonF {
    constructor(points) {
        this.points = points;
    }
    hashCode() {
        var _a, _b;
        let hash = 17;
        hash = 31 * hash + ((_b = (_a = this.points) === null || _a === void 0 ? void 0 : _a.hashCode()) !== null && _b !== void 0 ? _b : 0);
        return hash;
    }
    equals(other) { return other instanceof PolygonF && Kotlin_1.safeEq(this.points, other.points); }
    toString() { return `PolygonF(points = ${this.points})`; }
    copy(points = this.points) { return new PolygonF(points); }
    contains(point) {
        const intersections = Collections_1.iterCount(iterable_operator_1.range(0, this.points.length - 1), (it) => {
            const a = this.points[it];
            const b = this.points[(it + 1) % this.points.length];
            return Geometry_shared_1.Geometry.INSTANCE.rayIntersectsLine(point.x, point.y, point.x + 100, point.y, a.x, a.y, b.x, b.y);
        });
        return intersections % 2 === 1;
    }
}
exports.PolygonF = PolygonF;
//# sourceMappingURL=PolygonF.shared.js.map
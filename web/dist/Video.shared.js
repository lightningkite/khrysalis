"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: Video.shared.kt
// Package: com.lightningkite.khrysalis
const Kotlin_1 = require("./Kotlin");
//! Declares com.lightningkite.khrysalis.Video
class Video {
    constructor() {
    }
}
exports.Video = Video;
//! Declares com.lightningkite.khrysalis.VideoReference
class VideoReference extends Video {
    constructor(uri) {
        super();
        this.uri = uri;
    }
    hashCode() {
        var _a, _b;
        let hash = 17;
        hash = (_b = 31 * hash + ((_a = this.uri) === null || _a === void 0 ? void 0 : _a.hashCode())) !== null && _b !== void 0 ? _b : 0;
        return hash;
    }
    equals(other) { return other instanceof VideoReference && this.uri === other.uri; }
    toString() { return `VideoReference(uri = ${this.uri})`; }
    copy(uri = this.uri) { return new VideoReference(uri); }
}
exports.VideoReference = VideoReference;
//! Declares com.lightningkite.khrysalis.VideoRemoteUrl
class VideoRemoteUrl extends Video {
    constructor(url) {
        super();
        this.url = url;
    }
    hashCode() {
        let hash = 17;
        hash = 31 * hash + Kotlin_1.hashString(this.url);
        return hash;
    }
    equals(other) { return other instanceof VideoRemoteUrl && this.url === other.url; }
    toString() { return `VideoRemoteUrl(url = ${this.url})`; }
    copy(url = this.url) { return new VideoRemoteUrl(url); }
}
exports.VideoRemoteUrl = VideoRemoteUrl;
//! Declares com.lightningkite.khrysalis.asVideo>kotlin.String
function kotlinStringAsVideo(this_) { return new VideoRemoteUrl(this_); }
exports.kotlinStringAsVideo = kotlinStringAsVideo;
//! Declares com.lightningkite.khrysalis.asVideo>android.net.Uri
function androidNetUriAsVideo(this_) { return new VideoReference(this_); }
exports.androidNetUriAsVideo = androidNetUriAsVideo;
//# sourceMappingURL=Video.shared.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Generated by Khrysalis TypeScript converter
// File: collection.actual.kt
// Package: com.lightningkite.khrysalis
const Kotlin_1 = require("./Kotlin");
const Comparable_1 = require("./kotlin/Comparable");
//! Declares kotlin.collections.binarySearch>kotlin.collections.List
function xListBinarySearch(self, fromIndex = 0, toIndex = self.length, comparison) {
    let low = fromIndex;
    let high = toIndex - 1;
    while (low <= high) {
        const mid = (low + high) >>> 1;
        const midVal = self[mid];
        const cmp = comparison(midVal);
        if (cmp < 0)
            low = mid + 1;
        else if (cmp > 0)
            high = mid - 1;
        else
            return mid; // key found
    }
    return -(low + 1); // key not found
}
exports.xListBinarySearch = xListBinarySearch;
//! Declares kotlin.collections.binarySearchBy>kotlin.collections.List
function xListBinarySearchBy(self, key, fromIndex = 0, toIndex = self.length, selector) {
    return xListBinarySearch(self, fromIndex, toIndex, (x) => Comparable_1.safeCompare(key, selector(x)));
}
exports.xListBinarySearchBy = xListBinarySearchBy;
//! Declares com.lightningkite.khrysalis.withoutIndex>kotlin.collections.List
function xListWithoutIndex(this_WithoutIndex, index) {
    return Kotlin_1.also(Array.from(this_WithoutIndex), (this_) => this_.splice(index, 1));
}
exports.xListWithoutIndex = xListWithoutIndex;
//! Declares com.lightningkite.khrysalis.sumByLong>kotlin.collections.Iterable
function xIterableSumByLong(this_SumByLong, selector) {
    let sum = 0;
    for (const element of this_SumByLong) {
        sum = sum + selector(element);
    }
    return sum;
}
exports.xIterableSumByLong = xIterableSumByLong;
//! Declares com.lightningkite.khrysalis.binaryInsertBy>kotlin.collections.MutableList
function xMutableListBinaryInsertBy(this_BinaryInsertBy, item, selector) {
    const index = xListBinarySearchBy(this_BinaryInsertBy, selector(item), undefined, undefined, selector);
    if (index < 0) {
        this_BinaryInsertBy.splice(-index - 1, 0, item);
    }
    else {
        this_BinaryInsertBy.splice(index, 0, item);
    }
}
exports.xMutableListBinaryInsertBy = xMutableListBinaryInsertBy;
//! Declares com.lightningkite.khrysalis.binaryInsertByDistinct>kotlin.collections.MutableList
function xMutableListBinaryInsertByDistinct(this_BinaryInsertByDistinct, item, selector) {
    const index = xListBinarySearchBy(this_BinaryInsertByDistinct, selector(item), undefined, undefined, selector);
    if (index < 0) {
        this_BinaryInsertByDistinct.splice(-index - 1, 0, item);
        return true;
    }
    else {
        return false;
    }
}
exports.xMutableListBinaryInsertByDistinct = xMutableListBinaryInsertByDistinct;
//! Declares com.lightningkite.khrysalis.binaryFind>kotlin.collections.List
function xListBinaryFind(this_BinaryFind, key, selector) {
    const index = xListBinarySearchBy(this_BinaryFind, key, undefined, undefined, selector);
    if (index >= 0) {
        return this_BinaryFind[index];
    }
    else {
        return null;
    }
}
exports.xListBinaryFind = xListBinaryFind;
//! Declares com.lightningkite.khrysalis.binaryForEach>kotlin.collections.List
function xListBinaryForEach(this_BinaryForEach, lower, upper, selector, action) {
    let index = xListBinarySearchBy(this_BinaryForEach, lower, undefined, undefined, selector);
    if (index < 0) {
        index = -index - 1;
    }
    while (index < this_BinaryForEach.size) {
        const item = this_BinaryForEach[index];
        const itemK = selector(item);
        if (itemK === null || Comparable_1.safeCompare(item, upper))
            break;
        action(item);
        index++;
    }
}
exports.xListBinaryForEach = xListBinaryForEach;
//# sourceMappingURL=collection.actual.js.map
// Generated by Khrysalis Swift converter - this file will be overwritten.
// File: views/Strings.shared.kt
// Package: com.lightningkite.khrysalis.views
import Foundation

public protocol ViewString {
    
    func get(dependency: ViewDependency) -> String 
}


public class ViewStringRaw : ViewString {
    public var string: String
    public init(string: String) {
        self.string = string
    }
    
    public func get(dependency: ViewDependency) -> String { return self.string }
}

public class ViewStringResource : ViewString {
    public var resource: StringResource
    public init(resource: StringResource) {
        self.resource = resource
    }
    
    public func get(dependency: ViewDependency) -> String { return dependency.getString(resource: self.resource) }
}

public class ViewStringTemplate : ViewString {
    public var template: ViewString
    public var arguments: Array<Any>
    public init(template: ViewString, arguments: Array<Any>) {
        self.template = template
        self.arguments = arguments
    }
    
    public func get(dependency: ViewDependency) -> String {
        let templateResolved = self.template.get(dependency: dependency)
        let fixedArguments = self.arguments.map({ (it: Any) -> Any in (it as? ViewString)?.get(dependency: dependency) ?? it })
        return templateResolved.formatList(arguments: fixedArguments)
    }
}

public class ViewStringComplex : ViewString {
    public var getter:  (ViewDependency) -> String
    public init(getter: @escaping  (ViewDependency) -> String) {
        self.getter = getter
    }
    
    public func get(dependency: ViewDependency) -> String { return self.getter(dependency) }
}

public class ViewStringList : ViewString {
    public var parts: Array<ViewString>
    public var separator: String
    public init(parts: Array<ViewString>, separator: String = "\n") {
        self.parts = parts
        self.separator = separator
    }
    
    public func get(dependency: ViewDependency) -> String {
        return self.parts.map({ (it: ViewString) -> String in it.get(dependency: dependency) }).joined(separator: self.separator)
    }
}

public extension Array where Element == ViewString {
    func joinToViewString(separator: String = "\n") -> ViewString {
        if self.count == 1 {
            return self.first!
        }
        return ViewStringList(parts: self, separator: separator)
    }
}

public extension ViewString {
    func toDebugString() -> String {
        let thing = self
        if let thing = thing as? ViewStringRaw {
            return thing.string
        } else if let thing = thing as? ViewStringResource {
            return String(describing: thing.resource)
        } else if let thing = thing as? ViewStringTemplate {
            return thing.template.toDebugString() + "(" + thing.arguments.map({ (it: Any) -> String in run { () -> String in if let it = it as? ViewString { return it.toDebugString() } else { return "\(it)" }} }).joined(separator: ", ") + ")"
        } else if let thing = thing as? ViewStringList {
            return thing.parts.map({ (it: ViewString) -> String in it.toDebugString() }).joined(separator: thing.separator)
        } else if let thing = thing as? ViewStringComplex {
            return "<Complex string \(thing)>"
        } else  {
            return "Unknown"
        }
    }
}


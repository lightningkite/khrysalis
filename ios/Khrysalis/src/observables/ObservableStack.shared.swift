// Generated by Khrysalis Swift converter - this file will be overwritten.
// File: observables/ObservableStack.shared.kt
// Package: com.lightningkite.khrysalis.observables
import RxSwift
import Foundation

public class ObservableStack<T : AnyObject> : ObservableProperty<Array<T>> {
    override public init() {
        self._onChange = PublishSubject()
        self.stack = [] as Array<T>
        super.init()
        //Necessary properties should be initialized now
    }
    
    
    
    
    public var _onChange: PublishSubject<Array<T>>
    override public var onChange: PublishSubject<Array<T>> {
        get { return _onChange }
    }
    override public var value: Array<T> {
        get {
            return self.stack
        }
    }
    
    public var stack: Array<T>
    
    public func push(t: T) -> Void {
        self.stack.append(t)
        self.onChange.onNext(self.stack)
    }
    
    public func swap(t: T) -> Void {
        self.stack.remove(at: (self.stack.count - 1))
        self.stack.append(t)
        self.onChange.onNext(self.stack)
    }
    
    public func pop() -> Bool {
        if self.stack.count <= 1 {
            return false
        }
        self.stack.remove(at: (self.stack.count - 1))
        self.onChange.onNext(self.stack)
        return true
    }
    
    public func dismiss() -> Bool {
        if self.stack.isEmpty {
            return false
        }
        self.stack.remove(at: (self.stack.count - 1))
        self.onChange.onNext(self.stack)
        return true
    }
    
    public func backPressPop() -> Bool {
        let last = self.stack.last
        if let last = last as? HasBackAction, last.onBackPressed() { return true }
        return self.pop()
    }
    
    public func backPressDismiss() -> Bool {
        let last = self.stack.last
        if let last = last as? HasBackAction, last.onBackPressed() { return true }
        return self.dismiss()
    }
    
    public func popTo(t: T) -> Void {
        var found = false
        for i in ((0...(self.stack.count - 1))){
            if found {
                self.stack.remove(at: (self.stack.count - 1))
            } else { if self.stack[i] === t {
                    found = true
            } }
        }
        self.onChange.onNext(self.stack)
    }
    
    public func popTo(predicate: (T) -> Bool) -> Void {
        var found = false
        for i in ((0...(self.stack.count - 1))){
            if found {
                self.stack.remove(at: (self.stack.count - 1))
            } else { if predicate(self.stack[i]) {
                    found = true
            } }
        }
        self.onChange.onNext(self.stack)
    }
    
    public func root() -> Void {
        self.popTo(t: self.stack.first!)
    }
    
    public func reset(t: T) -> Void {
        self.stack.removeAll()
        self.stack.append(t)
        self.onChange.onNext(self.stack)
    }
}

public class ObservableStackCompanion {
    public init() {
        //Necessary properties should be initialized now
    }
    public static let INSTANCE = ObservableStackCompanion()
    
    public func withFirst<T : AnyObject>(value: T) -> ObservableStack<T> {
        let result = (ObservableStack() as ObservableStack<T>)
        result.reset(t: value)
        return result
    }
}


// Generated by Khrysalis Swift converter - this file will be overwritten.
// File: observables/EventToObservableProperty.shared.kt
// Package: com.lightningkite.khrysalis.observables
import RxSwift
import Foundation

public class EventToObservableProperty<T> : ObservableProperty<T> {
    private var _value: T
    override public var value: T { get { return self._value } set(value) { self._value = value } }
    public var wrapped: Observable<T>
    public init(value: T, wrapped: Observable<T>) {
        self._value = value
        self.wrapped = wrapped
        super.init()
        //Necessary properties should be initialized now
    }
    
    override public var onChange: Observable<T> {
        get { return Observable.concat(self.wrapped.map({ (it) -> T in 
                        self.value = it
                        return it
                }).doOnError({ (it) -> Void in 
                        print("  ❌ \("EventToObservableProperty"): \("Oh boy, you done screwed up.  The following stack trace is from an Observable that had an error that was converted to an ObservableProperty, which has a contract to never error.  The currently held value is '\(self.value)")")
                        it.printStackTrace()
        }).catchError { _ in Observable.never() }, Observable.never()) }
    }
}

public extension Observable {
    func asObservableProperty(defaultValue: Element) -> ObservableProperty<Element> {
        return (EventToObservableProperty(value: defaultValue as Element, wrapped: self.map({ (it) -> Element in it }) as Observable<Element>) as EventToObservableProperty<Element>)
    }
}

public extension Observable {
    func asObservablePropertyDefaultNull() -> ObservableProperty<Element?> {
        return (EventToObservableProperty(value: nil as Element?, wrapped: self.map({ (it) -> Element? in it }) as Observable<Element?>) as EventToObservableProperty<Element?>)
    }
}




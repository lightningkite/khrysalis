package com.lightningkite.khrysalis.web.layout

import com.lightningkite.khrysalis.utils.camelCase
import com.lightningkite.khrysalis.utils.forEachBetween
import com.lightningkite.khrysalis.utils.kabobCase
import org.apache.commons.lang3.StringEscapeUtils.escapeHtml4
import java.lang.Appendable
import java.net.URLEncoder

class ResultNode(
    var name: String = "div"
) {
    var parent: ResultNode? = null
    val other = HashMap<String, Any>()
    val classes = HashSet<String>()
    val stylesheet = ArrayList<String>()
    val style = HashMap<String, String>()
    val attributes = HashMap<String, String>()
    val contentNodes = ArrayList<Any>()
    val postProcess = ArrayList<ResultNode.() -> Unit>()
    var subtreeId: String? = null

    var primary: ResultNode = this
    var text: ResultNode = this
    var containerNode: ResultNode = this

    fun doPostProcess() {
        postProcess.forEach { it.invoke(this) }
        postProcess.clear()
        for (child in contentNodes.toList()) {
            if (child is ResultNode) {
                child.doPostProcess()
            }
        }
    }

    fun emitHtml(out: Appendable) {

        out.append("<$name ")
        out.append("class=\"")
        (classes + "khr").forEachBetween(
            forItem = { value ->
                out.append(value)
            },
            between = { out.append(" ") }
        )
        out.append("\"")
        if (style.isNotEmpty()) {
            out.append("style=\"")
            style.entries.forEachBetween(
                forItem = { (key, value) ->
                    out.append(key)
                    out.append(":")
                    out.append(value)
                },
                between = { out.append(";") }
            )
            out.append("\"")
        }
        if (attributes.isNotEmpty()) {
            for ((key, value) in attributes) {
                out.append(key)
                out.append("=\"")
                out.append(value.replace("\"", "&quot;"))
                out.append("\" ")
            }
        }
        if (contentNodes.isNotEmpty()) {
            out.append(">")
            for (node in contentNodes) {
                when (node) {
                    is String -> out.append(node.let { escapeHtml4(it) }.replace("\n", "<br>"))
                    is ResultNode -> node.emitHtml(out)
                }
            }
            out.append("</$name>")
        } else {
            out.append("></$name>")
        }
    }

//    fun emitClass(snakeCaseName: String, out: Appendable) {
//        //In order to find import paths, we'll likely have to scan all of the files.
//        //EWWW.
//        //Either that, or we need to define imports whenever we use them.  That might be OK?
//        //No, delegates need loading too.
//        val camelCaseName = snakeCaseName.camelCase()
//        val kabobCaseName = snakeCaseName.kabobCase()
//        out.appendln("//")
//        out.appendln("// ${camelCaseName}Xml.ts")
//        out.appendln("// Generated by Khrysalis")
//        out.appendln("//")
//        out.appendln("")
//        out.appendln("export class ${camelCaseName}Xml {")
//        //Emit view binding variable declarations - viewName!: ViewType; OR viewName?: ViewType;  import { ViewType } from ...
//        emitViewDecl(out)
//        //Emit delegate bindings - delegateName!: DelegateType; OR delegateName?: DelegateType;  import { DelegateType } from ...
//        //Emit sublayouts - subLayoutName: SomethingXml = new SomethingXml(); import { SomethingXml } from ./SomethingXml
//        out.appendln("xmlRoot!: HTMLElement;")
//        out.appendln("")
//        out.appendln("setup(dependency: Window): HTMLElement {")
//        //Emit HTML file loading and insertion - const view = loadHtmlFile("path/${snakeCaseName}.html"); import { loadHtmlFile } from khrysalis/dist/views/html
//        out.appendln("return setupView(view);")
//        out.appendln("}")
//        out.appendln("")
//        out.appendln("setupView(view: HTMLElement): HTMLElement {")
//        //Emit view binding initiation - this.viewName = findId(view, "id-view-name") as ViewType; import { findId } from khrysalis/dist/views/html
//        //Emit delegate init - this.delegateName = new DelegateType(); this.associatedView.delegate = this.delegateName; import { DelegateType } from ...
//        //Emit sublayout initiation and embedding - replaceView(findId(view, "id-sublayout-id"), this.subLayoutName.setup(dependency)); import { replaceView } from khrysalis/dist/views/html
//        //There's no cursing here.  This is a CHRISTIAN file.
//        out.appendln("}")
//
//        out.appendln("}")
//        out.appendln("")
//    }
//
//    fun viewsWithId(): List<ResultNode> =
//        if (this.subtreeId != null) listOf(this) + contentNodes.mapNotNull { it as? ResultNode }
//            .flatMap { it.viewsWithId() } else contentNodes.mapNotNull { it as? ResultNode }.flatMap { it.viewsWithId() }
//
}

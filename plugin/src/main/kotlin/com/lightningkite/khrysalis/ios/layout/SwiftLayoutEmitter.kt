package com.lightningkite.khrysalis.ios.layout

import com.lightningkite.khrysalis.generic.SmartTabWriter
import com.lightningkite.khrysalis.swift.replacements.TemplatePart
import org.jetbrains.kotlin.psi.KtFile
import java.io.BufferedWriter

class SwiftLayoutEmitter(val translator: SwiftLayoutTranslator, val name: String) : Appendable {
    val stringBuilder = StringBuilder()
    val out = SmartTabWriter(stringBuilder)
    private val imports = HashSet<TemplatePart.Import>()

    init {
        imports.add(TemplatePart.Import("Foundation"))
        imports.add(TemplatePart.Import("Khrysalis"))
    }

    var fileEndingActions = ArrayList<() -> Unit>()

    val sublayouts = HashMap<String, String>()
    val delegateBindings = HashMap<String, String>()
    val bindings = HashMap<String, String>()

    companion object {
        val overwriteWarning = "// Generated by Khrysalis Swift converter - this file will be overwritten."
    }

    fun write(writer: BufferedWriter) {
        writer.appendln(overwriteWarning)
        appendln("//")
        appendln("// ${name}Xml.swift")
        appendln("// Created by Khrysalis XML")
        appendln("//")
        appendln("")
        for (import in imports) {
            appendln("import $import")
        }
        appendln("")
        appendln("public class ${name}Xml {")
        appendln("")
        appendln("public unowned var xmlRoot: UIView!")

        appendln("public func setup(dependency: ViewDependency) -> UIView {")
        out.flush()
        writer.appendln(stringBuilder)
        appendln("xmlRoot = view")
        appendln("return view")
        appendln("}")
        appendln()
        sublayouts.entries.forEach {
            appendln("public let ${it.key}: ${it.value} = ${it.value}()")
        }
        delegateBindings.entries.forEach {
            appendln("public unowned var ${it.key}Delegate: ${it.value}!")
        }
        bindings.entries.forEach {
            appendln("public unowned var ${it.key}: ${it.value}!")
        }
        appendln()
        appendln("}")

        while (fileEndingActions.isNotEmpty()) {
            stringBuilder.clear()
            stringBuilder.appendln()
            val copy = fileEndingActions
            fileEndingActions = ArrayList()
            copy.forEach { it() }
            out.flush()
            writer.appendln(stringBuilder)
        }
    }

    fun addImport(part: TemplatePart.Import) {
        imports.add(part)
    }

    fun addImports(parts: Iterable<TemplatePart.Import>) {
        for (p in parts) addImport(p)
    }

    override fun append(p0: CharSequence): Appendable {
        out.append(p0)
        return this
    }

    override fun append(p0: CharSequence, p1: Int, p2: Int): Appendable {
        out.append(p0, p1, p2)
        return this
    }

    override fun append(p0: Char): Appendable {
        out.append(p0)
        return this
    }
}